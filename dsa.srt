1
00:00:03,280 --> 00:00:04,640
Hey everyone, welcome back to the channel.

2
00:00:04,800 --> 00:00:06,260
I hope you guys are doing extremely well.

3
00:00:06,620 --> 00:00:10,120
So this video is going to be another video from the Strivers A to Z DSA course.

4
00:00:10,800 --> 00:00:14,500
And this is India's most in-depth DSA Algo course.

5
00:00:14,640 --> 00:00:15,320
Why do I see that?

6
00:00:15,340 --> 00:00:18,180
Because this course has 455 modules.

7
00:00:18,760 --> 00:00:24,160
I can guarantee you that you can take any paid batches, any free courses, none of those

8
00:00:24,160 --> 00:00:26,180
courses will have 455 modules.

9
00:00:26,180 --> 00:00:32,340
This is an extremely in-depth DSA Algo course that can teach you everything in-breath about

10
00:00:32,340 --> 00:00:33,180
DSA Algo.

11
00:00:33,640 --> 00:00:37,900
And in the previous videos, we have covered step 1.1 and 1.2.

12
00:00:38,460 --> 00:00:43,100
And regarding step 1.3, I've added a video on C++ STL on the playlist.

13
00:00:43,560 --> 00:00:44,700
You can go and watch it.

14
00:00:44,960 --> 00:00:48,620
Regarding Java collection, I'll be adding a video in the future, not now.

15
00:00:48,840 --> 00:00:52,640
If you need a video now, you can go to YouTube and you'll find a lot of other resources from

16
00:00:52,640 --> 00:00:53,940
where you can study.

17
00:00:54,380 --> 00:00:57,960
So in this video, we will be discussing about basic maths.

18
00:00:58,440 --> 00:01:00,980
Why am I teaching just the basic maths as of now?

19
00:01:01,300 --> 00:01:04,220
So you're starting off as of now, your brain will not be that mature.

20
00:01:04,460 --> 00:01:09,560
So if I teach you the advanced level concepts, you might understand, but it won't be that

21
00:01:10,020 --> 00:01:10,920
convenient for you.

22
00:01:11,020 --> 00:01:13,140
That is why my teaching way is very different.

23
00:01:13,320 --> 00:01:16,240
What I do is I usually start off with the basic stuffs.

24
00:01:16,420 --> 00:01:19,680
I give you a lot of time to absorb it and then we move on to the advanced part.

25
00:01:19,880 --> 00:01:22,760
This is why all the basic stuffs are initially there.

26
00:01:22,760 --> 00:01:27,280
And then we move on to the DS Algo and in the step 8, we have a section as advanced

27
00:01:27,280 --> 00:01:27,900
mathematics.

28
00:01:28,020 --> 00:01:31,980
I'll be covering everything that is related to advanced mathematics that might be asked

29
00:01:31,980 --> 00:01:32,740
in interviews.

30
00:01:33,120 --> 00:01:35,380
But as of now, we will be learning basic maths.

31
00:01:35,780 --> 00:01:37,620
Now these are the problems which we will be solving.

32
00:01:38,120 --> 00:01:42,220
But before that, let's learn some basic maths concept.

33
00:01:42,820 --> 00:01:47,180
So before solving all the problems that are listed under basic maths, we'll be starting

34
00:01:47,180 --> 00:01:49,600
off with the basic maths concept.

35
00:01:49,600 --> 00:01:54,340
I'll be teaching you the concepts initially and then we can solve all the problems listed

36
00:01:54,340 --> 00:01:55,240
under the section.

37
00:01:55,780 --> 00:01:58,760
The first concept that I'll be teaching you is the digit concept.

38
00:01:59,340 --> 00:02:04,860
Remember one thing, this is a very, very important concept because if you know how to play around

39
00:02:06,080 --> 00:02:10,620
digits, then you'll be able to solve most of the problems in basic maths.

40
00:02:11,140 --> 00:02:12,740
Let's understand the digit concept.

41
00:02:12,740 --> 00:02:16,640
Imagine I give you a number like 7789.

42
00:02:17,700 --> 00:02:19,440
This is the number that I'm giving you.

43
00:02:19,780 --> 00:02:23,620
Now I ask you to perform extraction of digits.

44
00:02:24,460 --> 00:02:26,760
I ask you to perform extraction of digits.

45
00:02:27,480 --> 00:02:32,100
Let's learn the extraction of digits and after that you will see how we can implement the

46
00:02:32,100 --> 00:02:35,180
extraction of digits in order to solve most of the problems.

47
00:02:35,880 --> 00:02:38,500
So when I say extraction of digits, what does it mean?

48
00:02:38,500 --> 00:02:47,200
It means I need 9, I need 8, I need 7, I need 7, I need all the digits individually.

49
00:02:48,080 --> 00:02:49,480
So what is this digit?

50
00:02:49,940 --> 00:02:50,100
9.

51
00:02:50,800 --> 00:02:51,980
Can I say this?

52
00:02:52,480 --> 00:02:55,320
If I do a module of 10, I'll actually get 9.

53
00:02:55,780 --> 00:02:56,960
Now you might ask, why?

54
00:02:58,040 --> 00:03:01,820
If I ask you the numbers that are divisible by 10, what are they?

55
00:03:01,820 --> 00:03:10,380
10, 20, 30, 40, 50, 60, 70, so on, 100 and so on, do you see a pattern?

56
00:03:11,180 --> 00:03:16,000
All the numbers that are divisible by 10 are actually ending with 0, is it?

57
00:03:16,480 --> 00:03:16,700
Right?

58
00:03:17,340 --> 00:03:22,100
So can I say, if I'm doing a module of 10, what is the meaning of module operator in

59
00:03:22,100 --> 00:03:22,660
basic maths?

60
00:03:23,060 --> 00:03:27,900
The module operator says, I will divide the number by 10 and whatever is the remainder,

61
00:03:28,300 --> 00:03:29,460
that is what I'll give you.

62
00:03:29,460 --> 00:03:34,620
So if I see, if I'm dividing this number by 10, what is the nearest number?

63
00:03:35,580 --> 00:03:38,780
Obviously, that will be 7, 7, 8, 0.

64
00:03:39,380 --> 00:03:42,640
If I divide it by 10, this is what the nearest number will be.

65
00:03:43,020 --> 00:03:45,660
And can I say that the remainder then will be 9?

66
00:03:46,220 --> 00:03:50,720
Because if I divide it by 10, then this is where the division, like this is the number

67
00:03:50,720 --> 00:03:52,820
which will get divided by 10.

68
00:03:54,060 --> 00:03:56,380
And after that, we'll be left out with 9.

69
00:03:56,380 --> 00:04:03,020
That is why when you do a module of 10, you always get the last digit, you get the last

70
00:04:03,020 --> 00:04:04,280
digit as 9.

71
00:04:04,800 --> 00:04:06,060
So this is how you get the 9 digit.

72
00:04:06,560 --> 00:04:09,360
If I ask you, can I get the next digit 8?

73
00:04:09,960 --> 00:04:11,300
How will you get the next digit 8?

74
00:04:11,740 --> 00:04:12,380
Very simple.

75
00:04:12,840 --> 00:04:15,660
You say, okay, this number, let's divide it by 10.

76
00:04:16,200 --> 00:04:23,020
So if I divide 7, 7, 8, 9 by 10, can I say I'll get 7, 7, 8, 0.9?

77
00:04:23,620 --> 00:04:24,200
Can I say this?

78
00:04:24,580 --> 00:04:29,680
If I divide the number 7, 7, 8, 9 by 10, I'll get 7, 7, 8, 0.9.

79
00:04:30,120 --> 00:04:34,960
And if I take an integer round off, if I take an integer portion of it, the integer portion

80
00:04:34,960 --> 00:04:36,580
is 7, 7, 8.

81
00:04:36,980 --> 00:04:42,180
So what you will do is, in order to go to the next step, you will say, divide by 10.

82
00:04:42,680 --> 00:04:48,700
If you do a division by 10, you'll actually get 7, 7, 8, 0.9, but you just take the integer

83
00:04:48,700 --> 00:04:49,020
part.

84
00:04:49,260 --> 00:04:51,480
That is why you get 7, 7, 8.

85
00:04:51,860 --> 00:04:57,180
So once you have 7, 7, 8 with you, if I need the last digit, which is 8, how do you extract

86
00:04:57,180 --> 00:04:57,480
it?

87
00:04:57,880 --> 00:05:02,240
Again, the same way, you say, can I divide, modularize with 10?

88
00:05:02,900 --> 00:05:06,040
If I do a mod of 10, I'll actually get 8, why?

89
00:05:06,380 --> 00:05:11,080
Because the nearest number will be 7, 7, 0, which is divisible by 10, which will still

90
00:05:11,080 --> 00:05:15,200
leave a remainder of 8, so I get the digit 8 as well.

91
00:05:15,200 --> 00:05:21,200
Now, can I see if I require the next digit 7, can I again do a division by 10?

92
00:05:21,900 --> 00:05:26,560
If I do a division by 10, can I say I'll get 77, why?

93
00:05:26,740 --> 00:05:35,640
Because if I write 7, 7, 8 by 10, I'll get 77.8, and the integer portion is 77, so I

94
00:05:35,640 --> 00:05:36,280
get 77.

95
00:05:36,800 --> 00:05:41,780
Again, if I have to extract the last digit, can I say I'll do a modularize, a modular

96
00:05:41,780 --> 00:05:43,300
of 10, and I'll get 7?

97
00:05:43,300 --> 00:05:51,140
Again, I will, hence I've again extracted 7, now if I need the next extraction, I again

98
00:05:51,140 --> 00:05:58,600
divide it by 7, so I divide it by 10, and I'll get 7, because 77, because 77 divided

99
00:05:58,600 --> 00:06:03,000
by 10 is 7.7, and the integer part is 7, so I get 7.

100
00:06:03,380 --> 00:06:09,560
If I do a modularize of 10, I'll actually again get 7, why will you get again 7?

101
00:06:09,560 --> 00:06:17,160
Very obvious because the nearest number that is divisible by 10 to 7 is 0, thereby you

102
00:06:17,160 --> 00:06:19,780
get a remainder of 7, so you get 7.

103
00:06:20,340 --> 00:06:25,380
After that, if you again try to divide it by 10, this time you'll end up getting 0,

104
00:06:25,800 --> 00:06:32,560
because if I take 7 divided by 10, it'll be 0.7, hence the integer part is 0, so can I

105
00:06:32,560 --> 00:06:38,220
say if I get an integer part as 0, can I say I've extracted all the digits I have, and

106
00:06:38,220 --> 00:06:43,340
if you see the extraction has been done in the reverse order, and all the digits have

107
00:06:43,340 --> 00:06:49,400
been extracted, as simple as that, so this is how you can easily extract all the digits.

108
00:06:49,620 --> 00:06:52,420
So if I try to write the pseudocode, how will the pseudocode look like?

109
00:06:52,900 --> 00:06:58,780
Can I say, if I have the N, I can take it from the user, I can take the N from the user,

110
00:06:59,160 --> 00:07:04,520
and imagine I'm asking you to print all the digits, extract all the digits like 9, 8,

111
00:07:04,520 --> 00:07:07,540
7, 7, and you can print it, so how will you do it?

112
00:07:07,540 --> 00:07:08,500
It's very simple.

113
00:07:09,340 --> 00:07:13,980
I will be like, okay while, I know what is the last step, last step is, the extraction

114
00:07:13,980 --> 00:07:22,320
goes on from N when it is 7789 to N till 0, so I'll be like, I'll go on till N is greater

115
00:07:22,320 --> 00:07:27,840
than 0, which means till N doesn't becomes 0, right, and can I say, the extraction is

116
00:07:27,840 --> 00:07:34,600
very simple, the first time N was 7789, if I had to do an extraction, it's very simple,

117
00:07:34,600 --> 00:07:42,440
can I say the last digit is nothing but N modularized N, if I do an N modularized N,

118
00:07:42,580 --> 00:07:48,600
I'll get the last digit 9, and in order to get the next digit, what I do is, I say N

119
00:07:48,600 --> 00:07:55,220
is N by 10, and this is how I can do it, so what will happen, let's do a dry run, at first

120
00:07:55,220 --> 00:08:03,540
imagine I give, the user gives N as 7789, so this says 7789 greater than 0, which is

121
00:08:03,540 --> 00:08:11,080
true, so the last digit happens to be 7789 modularized N, hence the last digit is 9,

122
00:08:11,560 --> 00:08:16,540
if you want to print this last digit, you can definitely put a print operation, in C++

123
00:08:16,540 --> 00:08:22,360
it is C out, in Java it is system.out.println, so you can go ahead and print the 9, once

124
00:08:22,360 --> 00:08:29,480
you have done this, can I say if you do 7789 by 10, then the N will reduce itself, what

125
00:08:29,480 --> 00:08:35,860
will be the value of N now, can I say the value of N will be nothing but 778, this is

126
00:08:35,860 --> 00:08:41,460
how the first iteration, first iteration will happen, and then it will reach here, then

127
00:08:41,460 --> 00:08:46,040
again goes here, when it goes here, it will be a new iteration, and can I say this time

128
00:08:46,040 --> 00:08:54,400
the iteration will be 778, because N has changed itself to 778, and 778 greater than 0, what

129
00:08:54,400 --> 00:08:58,360
I'll do is, I'll quickly erase this, because it's the next iteration, so let's quickly

130
00:08:58,360 --> 00:09:06,400
erase this, and the next iteration what will happen, it will say 778 modularized N, the

131
00:09:06,400 --> 00:09:10,760
last digit this time will be 8, again you can print that last digit, and this time it

132
00:09:10,760 --> 00:09:18,840
will be 778 by 10, hence N will become 77, again the iteration will go and will be 77

133
00:09:18,840 --> 00:09:24,680
greater than 0, and this way all these steps will be performed at the end of the day, the

134
00:09:24,680 --> 00:09:30,480
value of N, yes the value of the N will be 0, hence the while loop will be false, and

135
00:09:30,480 --> 00:09:36,240
I can say that the execution has been completed, and you have successfully extracted all the

136
00:09:36,240 --> 00:09:41,580
digits in the reverse fashion, very important in the reverse fashion, got it, this is what

137
00:09:41,580 --> 00:09:46,520
is the concept of extraction of digits, and this is going to help you solve a lot of other

138
00:09:46,520 --> 00:09:47,380
problems as well.

139
00:09:48,180 --> 00:09:53,560
So now let's look at the first problem, it states count digits, let's understand the

140
00:09:53,560 --> 00:09:59,600
problem, given the number N, find out and return the digits present in a number, very

141
00:09:59,600 --> 00:10:06,340
simple, it says 156 is the number, and the number of digits is 3, imagine the N is given

142
00:10:06,340 --> 00:10:11,680
as 7, it has just one digit, so it will be given an N, and it will tell me the number

143
00:10:11,680 --> 00:10:18,340
of digits, so if I go back to my iPad, can I say, if I give you the number 7789, this

144
00:10:18,340 --> 00:10:24,960
has 4 digits, can you solve this problem, using the extraction of digits, can you, you

145
00:10:24,960 --> 00:10:29,980
will be like, this is super easy, why, because you know the extraction of digits, you know

146
00:10:29,980 --> 00:10:36,540
one digit, two digit, three digit, four digit, the digits are extracted four times, so can

147
00:10:36,540 --> 00:10:41,820
I say, I can give something like a counter variable over here, and you know the number

148
00:10:41,820 --> 00:10:47,860
of times the extraction happens, that is the number of times the digit will be, so can

149
00:10:47,860 --> 00:10:54,820
I say, I can put a counter equal to counter plus 1 on the logic of extraction of digits,

150
00:10:55,180 --> 00:11:01,260
if I do this, can I say, I'll be able to count the number of digits, and eventually if I

151
00:11:01,260 --> 00:11:07,560
print the count over here, can I say, that I'll always have the count of digits of any

152
00:11:07,560 --> 00:11:13,820
given N I can. Usually in coding rounds or in your interviews, you just have to code

153
00:11:13,820 --> 00:11:18,220
the function, the function is an int function, that means you have to return the count of

154
00:11:18,220 --> 00:11:23,160
digits, and they'll be giving you the input, so you are given the variable, you just have

155
00:11:23,160 --> 00:11:27,080
to return, you have to just write the code inside the function, int main and everything

156
00:11:27,080 --> 00:11:31,200
will be written on the backend, I've already discussed about this in the pattern video,

157
00:11:31,300 --> 00:11:35,740
in case you haven't watched it, please go back and watch it. So this was the code that

158
00:11:35,740 --> 00:11:42,360
we discussed on the iPad, right, so the count stores the count of digits, so I'll just return

159
00:11:42,360 --> 00:11:46,620
the count, and then I'll go ahead and run the code, and I'll see that it is running

160
00:11:46,620 --> 00:11:51,400
absolutely fine, and then I'll go ahead and submit this. So this is how you can easily

161
00:11:51,400 --> 00:11:56,400
solve this particular problem. Now remember one thing, this last digit does not have any

162
00:11:56,400 --> 00:12:01,700
significance, so you can remove it. So that was for extraction of digits, but this is

163
00:12:01,700 --> 00:12:06,740
kind of reducing the numbers, so the number of times it is divisible by 10 is the number

164
00:12:06,740 --> 00:12:13,420
of times the digits are. Now since I've removed the modular operation, we observe something,

165
00:12:14,080 --> 00:12:19,280
can I say the number of times it is getting divisible by 10, the number of times it is

166
00:12:19,280 --> 00:12:25,280
getting divisible by 10 is the count of the digits, it is, and this is where something

167
00:12:25,280 --> 00:12:32,660
like logarithmic, log base 10, 7789, if you do this in your calculator, you'll actually

168
00:12:32,660 --> 00:12:37,660
get something like 3.89 something. So this is the value that you'll get if you do a log

169
00:12:37,660 --> 00:12:45,080
base 10 of the number, and then if you can add a 1 to it, this will be 4.89, and if you

170
00:12:45,080 --> 00:12:51,500
take an integer of it, that will be 4. This is another way to find count of digits. What

171
00:12:51,500 --> 00:13:00,320
you do is very simple, you say count is equal to log 10, the number, plus 1, and you're

172
00:13:00,320 --> 00:13:05,460
saying take the integer, or you can just autocast it, like typecast it to integer.

173
00:13:06,620 --> 00:13:12,460
This is how, whatever you get, this is converted to an integer. If you're getting 4.89, it

174
00:13:12,460 --> 00:13:18,140
will be truncated to 4. And now let's run this and see if it is running fine. Okay,

175
00:13:18,180 --> 00:13:24,860
so it says out of scope, log 10 was not declared. So if you find such errors, what you can do

176
00:13:24,860 --> 00:13:30,600
is you can go to hash include. That's basically because in their backend, they might not have

177
00:13:30,600 --> 00:13:35,400
added all the directories. You can go ahead and add all the directories and that will

178
00:13:35,400 --> 00:13:39,260
start working fine. Once you've done this, you can go and compile and you're seeing that

179
00:13:40,300 --> 00:13:45,180
this is also running fine. This is one of the other ways to count digits as well. But

180
00:13:45,660 --> 00:13:49,980
the primary concept is extraction of digits and that is what you should focus on. Now

181
00:13:49,980 --> 00:13:55,560
if I discuss the time complexity over here, what will be the time complexity? The time

182
00:13:55,560 --> 00:14:03,360
complexity will be nothing but log base 10 N. This is the big go of time complexity.

183
00:14:04,300 --> 00:14:11,020
Why log base 10 N? The reason was very simple. You saw this is getting divisible by 10. How

184
00:14:11,020 --> 00:14:16,100
many times is the loop running? The number of times it is getting divisible by 10. This

185
00:14:16,100 --> 00:14:23,800
is why you will see time complexity is near about log base 10 N. This was 3.89 near about

186
00:14:23,800 --> 00:14:30,080
4. The number of times this loop did run was 4. Yeah, you can avoid these operations. These

187
00:14:30,080 --> 00:14:35,920
are single operations because imagine the number being very large. These will be considered

188
00:14:35,920 --> 00:14:43,820
as unit operations. That is why the time complexity is log base 10 N. Got it? Whenever there is

189
00:14:43,820 --> 00:14:48,020
division, remember this, whenever there is division, if the division is happening by

190
00:14:48,020 --> 00:14:54,840
10, you say log base 10 N. If the division is happening by 2, you say log base 2 N. If

191
00:14:54,840 --> 00:15:00,860
the division is happening by 5, you say log base 5 N. This is how you compute the time

192
00:15:00,860 --> 00:15:06,640
complexity of like, this is how the logarithmic time complexities are. So whenever you're

193
00:15:06,640 --> 00:15:14,600
writing a logic where the number of iterations depends on division and you're dividing, dividing,

194
00:15:14,980 --> 00:15:21,120
that is when something like logarithmic will come into the time complexity. That time the

195
00:15:21,120 --> 00:15:26,500
time complexity will not be VGO of N. If the number of iterations is based on division,

196
00:15:26,840 --> 00:15:32,080
time complexity will be logarithmic. Remember this always. So you solved the first problem

197
00:15:32,080 --> 00:15:36,760
count digits. The next problem is reverse a number. Let's go to the problem. It states

198
00:15:36,760 --> 00:15:41,460
write a program to generate the reverse of a given number. Print the corresponding reverse

199
00:15:41,460 --> 00:15:46,380
number. If a number has trailing zeros, then its reverse will not include them. For example,

200
00:15:46,600 --> 00:15:53,860
the reverse of 100400 will be 401 instead of 00401 and these are some of the examples.

201
00:15:54,820 --> 00:16:01,300
So let's get back to our extraction of digits concept. So according to the problem, what

202
00:16:01,300 --> 00:16:07,020
they are wanting is, if I'm giving you the number 7789, the reverse of this number will

203
00:16:07,020 --> 00:16:14,860
be 9877. Now we know that the extraction of digits happens in the reverse fashion where

204
00:16:14,860 --> 00:16:22,820
we generate 9, then we generate 8, then we get 7, then we get 7. Somehow we need 9877

205
00:16:23,160 --> 00:16:29,380
which is the similar fashion. This is where the basic maths comes in. What you do is,

206
00:16:30,280 --> 00:16:39,800
you define a variable sum or maybe reverse number. Reverse number equal to zero. And

207
00:16:39,800 --> 00:16:51,740
you say reverse number equal to reverse number into 10 plus last digit. Remember this. This

208
00:16:51,740 --> 00:16:59,020
is what you say. Reverse number into 10 plus last digit. Let's see how it works. So I'm

209
00:16:59,020 --> 00:17:06,040
saying initially reverse number is zero to start off. Let's do the step by step. First

210
00:17:06,040 --> 00:17:13,180
step, 9 gets generated. So what am I doing is, zero into 10 because reverse number is

211
00:17:13,180 --> 00:17:22,420
zero at the first step. At the first step, 7789, 10 will generate 9 and N would have

212
00:17:22,420 --> 00:17:31,180
as of now become something like 7789 by 10. So N would have as of now become 778 and reverse

213
00:17:31,180 --> 00:17:39,060
number says, reverse number is zero into 10 plus the last digit 9. So the number becomes

214
00:17:39,060 --> 00:17:45,080
or rather the reverse number as of now is 9. Right? This is what the first iteration

215
00:17:45,080 --> 00:17:51,160
is. Let's do the next iteration. The next iteration will be, I'll just quickly omit

216
00:17:51,160 --> 00:18:01,020
this off. So the next iteration, can I say it's 778 greater than zero and 778 modulo

217
00:18:01,020 --> 00:18:07,840
10. Hence the last digit is 8. I can't say this. And this will be 778 by 10. So N will

218
00:18:07,840 --> 00:18:15,480
become 77. This time, reverse number is stored as 9 because you stored reverse number as

219
00:18:15,480 --> 00:18:22,740
this value. So this is 9. So what do you do is, you say 9 into 10 plus the last digit

220
00:18:22,740 --> 00:18:30,900
8. What do you get is, 9 into 10 plus the last digit 8 which makes it 98. The next time

221
00:18:30,900 --> 00:18:41,760
you get 7, the reverse is 98 into 10 plus 7 which is 987. Next time it is 7. So 987

222
00:18:42,260 --> 00:18:52,480
into 10 plus 7 is 9877. So you got the reverse number there. Why it's simple? Why did this

223
00:18:52,480 --> 00:18:58,260
work? It's very easy. Understand, you're getting in last digit, you're easily getting

224
00:18:58,260 --> 00:19:04,060
the last digit, 9. And after that you're getting the next last digit 8 and you somehow want

225
00:19:04,060 --> 00:19:11,400
to add 8 to that 9. You somehow want to add 8 to that 9. And the easiest way is, if you

226
00:19:11,400 --> 00:19:17,440
can somehow add a zero to this 9, it will become 90. And then if you add 8 to it, it

227
00:19:17,440 --> 00:19:22,780
will become 98. Similarly, if you want to add 7 to it, if you want to add a 7 to it,

228
00:19:23,080 --> 00:19:29,620
make it 987. You again add a zero and then a 7 to it, it becomes 987. Again, if you want

229
00:19:29,620 --> 00:19:36,300
to add a 7, you again add a zero. This is why at every step, I am doing reverse number

230
00:19:36,840 --> 00:19:41,740
into 10. Whatever you have generated into 10, that will allow the last unit digit to

231
00:19:41,740 --> 00:19:47,360
be zero. Then when you add a digit, it goes and gets into that place. As simple as that.

232
00:19:49,740 --> 00:19:54,320
So again, you saw that extraction of digits is actually handy. So what I'll do is I'll

233
00:19:54,320 --> 00:20:01,000
take the number and I'll keep the reverse num equal to zero. And then I'll go ahead

234
00:20:01,000 --> 00:20:08,260
and say n greater than zero. And I can say last digit is n modulo 10. I can say reverse

235
00:20:08,260 --> 00:20:15,740
number is reverse number into 10 plus last digit. And I can say n is n by 10. And the

236
00:20:15,740 --> 00:20:22,420
same time I can say cout of reverse number is what I need. Perfect. And I'll quickly

237
00:20:22,420 --> 00:20:26,260
run the code and see if it is running fine. It is. Let's quickly sum up this and this

238
00:20:26,260 --> 00:20:32,280
should be running fine. This dead. So the reverse number is solved again with the concept

239
00:20:32,280 --> 00:20:38,700
of extraction of digits. Next problem is check palindrome. Now when I go to the palindrome

240
00:20:38,700 --> 00:20:43,800
problem, let's understand the problem. It states write a program to determine if a given

241
00:20:43,800 --> 00:20:50,620
number is palindrome or not. Print true if it is palindrome or false otherwise. So over

242
00:20:50,620 --> 00:20:56,500
here it states palindrome are the numbers for which reverse is exactly same as the original

243
00:20:56,500 --> 00:21:01,860
one. For example one to one. Because if you take one to one and you do a reverse of it,

244
00:21:02,440 --> 00:21:07,880
one to one's reverse is one to one. That is why it is called as palindrome. So if I go

245
00:21:07,880 --> 00:21:14,280
to the iPad and I write some other palindrome numbers, it's like one double three one. If

246
00:21:14,280 --> 00:21:20,500
you write the reverse of it, it stays still one double three one. Something like 11. 11

247
00:21:20,500 --> 00:21:26,660
in itself is a palindrome. Seven. Seven in itself is a palindrome. Whereas one to three,

248
00:21:27,000 --> 00:21:32,020
the reverse of one to three is three to one. This is not a palindrome. So any number which

249
00:21:32,020 --> 00:21:37,540
on reversal is the same number is a palindrome number. So the definition of palindrome number

250
00:21:37,540 --> 00:21:43,900
says reverse of a number. So if I somehow can generate the reverse of a number, if I somehow

251
00:21:43,900 --> 00:21:49,080
can generate the reverse of a number, which I've already did and then compare it with the original

252
00:21:49,080 --> 00:21:54,740
N and if they come out to be same, can I say they are palindrome? I can. So over here, if you

253
00:21:54,740 --> 00:22:00,900
remember, we took a reverse number and at the end of the day, the reverse number was nothing but the

254
00:22:00,900 --> 00:22:07,480
reverse number. And now if I can compare this reverse number with the original number, with the

255
00:22:07,480 --> 00:22:12,360
original number, which is N and if they come out to be same, I can say it is palindrome. Like if

256
00:22:12,360 --> 00:22:18,200
this is true, I can say it is palindrome or I can say it is not palindrome. Can I say it? But wait,

257
00:22:18,920 --> 00:22:29,860
if you remember, we were dividing N by 10 and at the end of the day, N was zero. So does N have

258
00:22:29,860 --> 00:22:36,820
the original number? No, because we are doing operations with N, which has made N to be zero

259
00:22:36,820 --> 00:22:44,080
at the end of the day. So what I need to do is maybe I need to store a duplicate of N in some

260
00:22:44,080 --> 00:22:52,100
top variable and instead of comparing it with N, I can compare it with a duplicate because N will

261
00:22:52,620 --> 00:22:59,120
be zero at the end of the extraction of digits. It's very important to store a copy of N somewhere

262
00:22:59,120 --> 00:23:05,040
so that it can be used to compare it with the reverse of a number. That is the only change

263
00:23:05,040 --> 00:23:08,160
that you have to do and that is the only thing that you have to keep in mind. So if you remember,

264
00:23:08,280 --> 00:23:12,200
this was the code. So what I'll do is I'll just go ahead and say duplicate equal to N

265
00:23:12,700 --> 00:23:18,540
and over here I say if do is equal to equal to reverse number, I can go ahead and print true,

266
00:23:18,780 --> 00:23:24,920
which is what they want, which is true or else you can just go ahead and print false.

267
00:23:25,520 --> 00:23:33,380
That is what they required. I'll quickly run it and see if it is running fine. It should be and

268
00:23:33,380 --> 00:23:39,520
let's quickly submit this. On submitting you see that it is running absolutely fine. The next one

269
00:23:39,520 --> 00:23:46,220
is GCD or HCF but before that we will be solving Armstrong numbers. So what is the definition of

270
00:23:46,220 --> 00:23:52,440
Armstrong number? It's very simple. Imagine you're given this number 371. You take three cube,

271
00:23:53,420 --> 00:23:59,840
seven cube plus one cube. If taking the cubes of these numbers like cubes of these digits

272
00:23:59,840 --> 00:24:05,760
and adding them up sums up to the number itself, that is what you call as an Armstrong number.

273
00:24:05,760 --> 00:24:12,920
Even if you take 1634, one cube plus six cube plus three cube plus four cube, if you sum them up,

274
00:24:12,920 --> 00:24:21,260
you actually get 1634. But something like 35, if you take three cube plus five cube, this is not

275
00:24:21,260 --> 00:24:29,520
going to be equal to 35. This is going to be equal to 134. So this and this are not same. Whereas 1634

276
00:24:29,520 --> 00:24:36,860
and the summation of cubes of its digits is 1634. So you call 1634 as an Armstrong number

277
00:24:36,860 --> 00:24:42,000
or 371 as an Armstrong number. So I hope you've got the definition of Armstrong number.

278
00:24:42,420 --> 00:24:46,340
If you have got the definition of Armstrong number, you know how to solve it. I've already

279
00:24:46,340 --> 00:24:51,820
taught you the extraction of digits. You know how do you extract nine? You know how do you extract

280
00:24:51,820 --> 00:24:58,460
eight? You know how do you extract seven? You just have to do a cube of it. So can I see this time

281
00:24:58,460 --> 00:25:05,280
instead of taking any such duplicate or reverse n, I can just take a summation because I need to

282
00:25:05,280 --> 00:25:14,560
sum cubes and last digit is what I have to sum. Can I say sum equal to sum plus last digit multiplied

283
00:25:14,560 --> 00:25:21,580
thrice, last digit into last digit into last digit. Can I do this? So first time nine comes in,

284
00:25:21,580 --> 00:25:28,740
what happens? Nine into nine into nine gets added to sum. Next time eight comes in,

285
00:25:29,080 --> 00:25:33,760
eight into eight into eight gets added to the sum. So everything is getting added.

286
00:25:34,320 --> 00:25:40,860
First time, nine into nine, sorry, nine into nine into nine got, next time eight went eight

287
00:25:40,860 --> 00:25:45,560
into eight into eight. Next time, seven came in seven into seven into seven. Next time again,

288
00:25:45,720 --> 00:25:49,660
seven came in seven into seven into seven. So can I say at the end of the day,

289
00:25:49,660 --> 00:25:56,060
Some will be storing the summation of digit cubes and after that you need to

290
00:25:56,060 --> 00:26:00,640
just compare it with the original end. So maybe again keep a duplicate variable

291
00:26:00,640 --> 00:26:05,280
which stores the end because at the end of the day you have to compare if this

292
00:26:05,280 --> 00:26:10,520
and the duplicate are same. If this is, then you say it is announced. If this is not,

293
00:26:10,700 --> 00:26:16,180
it's not announced. Again what logic worked? Extraction of digits. If you know

294
00:26:16,180 --> 00:26:19,500
how to extract digits, you can play around with them and you can solve this

295
00:26:19,500 --> 00:26:23,860
problem. So Armstrong number is completed and the next problem that we will be

296
00:26:23,860 --> 00:26:29,780
doing is print all divisors. So when I say print all divisors, what does it mean?

297
00:26:30,140 --> 00:26:34,540
Imagine I take a number like 36 and ask you what are all the numbers that divide

298
00:26:34,540 --> 00:26:40,680
36. So you can say 1 is something which completely divides 36. You can say 2 is

299
00:26:40,680 --> 00:26:44,620
something which completely divides 36. You can again say 3 is something which

300
00:26:44,620 --> 00:26:50,340
completely divides 36. 4 is something which completely divides. Is 5 something

301
00:26:50,340 --> 00:26:56,400
which completely divides 36? No. If 36 is divided by 5, it leaves a remainder of 1.

302
00:26:56,540 --> 00:27:03,640
So not 5. 6 is something which does it. 9 is something which does it. And 12 is

303
00:27:03,640 --> 00:27:08,460
something which does it. And 18 is something which does it. And then 36 is

304
00:27:08,460 --> 00:27:14,520
something which does it. If I talk about 36, the divisors of 36 are 1, 2, 3,

305
00:27:14,520 --> 00:27:22,300
4, 6, 9, 12, 18 and 36. These are the divisors of 36. The question is very

306
00:27:22,300 --> 00:27:28,460
straightforward. You have to print all of them in this particular order. Okay. Now

307
00:27:28,460 --> 00:27:34,560
how do I do it? It's very simple. One thing I know for sure is if I'm talking about

308
00:27:34,560 --> 00:27:39,860
divisors or factors, they're definitely going to lie between 1 to the number

309
00:27:39,860 --> 00:27:46,320
itself. Can I say all the divisors will be between 1 to n itself because

310
00:27:46,320 --> 00:27:51,880
anything greater than n will never divide n for sure? So if I know all the

311
00:27:51,880 --> 00:27:58,180
divisors are going to be between 1 and n, can I just loop from 1 to n? That's my

312
00:27:58,180 --> 00:28:02,680
first thought process. Since I know the divisors are from 1 to n, my first

313
00:28:02,680 --> 00:28:07,000
thought process is very simple. Then let's do one. Let's start the loop from i

314
00:28:07,000 --> 00:28:12,820
equal to 1, i lesser than equal to n and i plus plus. This is something I know

315
00:28:12,820 --> 00:28:17,480
for sure. So i is used to loop around. Now the first value of i is 1, then it's 2,

316
00:28:17,600 --> 00:28:22,940
then it's 3, then it's 4, then it's 5 and then so on till 36 in this case if it is

317
00:28:22,940 --> 00:28:29,640
n. So how do you determine that this i is a part of all the divisors? It's very

318
00:28:29,640 --> 00:28:41,600
Can I say if it is completely dividing, if i is completely dividing n, then it is a

319
00:28:41,600 --> 00:28:46,160
factor or a divisor. And what do you mean by completely dividing? It should leave a

320
00:28:46,160 --> 00:28:51,920
remainder of 0. When I say leaving a remainder of 0, does it mean if I do a

321
00:28:51,920 --> 00:28:58,240
modulated of i, if I do n module i, the value should be 0 because it's

322
00:28:58,240 --> 00:29:05,720
completely divisible. But what I will do is I'll say okay if n module i is equal

323
00:29:05,720 --> 00:29:11,420
to equal to 0, I will go ahead and print i in C++, C out in Java system dot out dot

324
00:29:11,420 --> 00:29:17,000
print out. I'll go ahead and print out i. In this way I'll be able to print all the

325
00:29:17,000 --> 00:29:22,760
factors of a particular n. If I talk about the time complexity, ask you what

326
00:29:22,760 --> 00:29:26,180
is the time complexity of this code? You'll be like Stryver, it's very simple.

327
00:29:26,180 --> 00:29:31,820
Since the loop is running from 1 to n, it's taking n iterations. And this is an

328
00:29:31,820 --> 00:29:35,960
unit operation so let's not calculate it. Thereby the time

329
00:29:35,960 --> 00:29:41,320
complexity of this particular approach is nothing but BGO of n. Very simple.

330
00:29:41,660 --> 00:29:45,640
Over here they've given us everything. They want us to write this print divisors

331
00:29:45,640 --> 00:29:49,880
function. Let's write the print divisors function. It takes an n and as I said

332
00:29:49,880 --> 00:29:56,200
it's very simple. You go from 1, you go on till n, let me say i, this one. And you

333
00:29:56,200 --> 00:30:02,120
know if n module i is equal to equal to 0, you say C out i and then you give a

334
00:30:02,120 --> 00:30:04,460
bit of space. That's what you need to write.

335
00:30:06,880 --> 00:30:11,820
And on submitting you will see that this is running absolutely fine. But the time

336
00:30:11,820 --> 00:30:18,300
complexity is BGO of n. I don't want a BGO of n time complexity. Can I do it in

337
00:30:18,300 --> 00:30:22,300
a much better way? I can't. But it requires a bit of mathematical observation.

338
00:30:22,860 --> 00:30:29,820
Let's see that mathematical observation. So for 36 I said that 1 was a factor. If

339
00:30:29,820 --> 00:30:35,740
1 is a factor, 1 has to be multiplied with something in order to get 36. So 1

340
00:30:35,740 --> 00:30:43,600
was multiplied with 36. And if you carefully observe, if this is 1 and the

341
00:30:43,600 --> 00:30:51,500
number is 36, the other number will always be n by 1. Very simple. If it is 2, the other

342
00:30:51,500 --> 00:30:58,960
number will be n by 2 which is 36 by 2. That means 18. So you get 18. Next time it

343
00:30:58,960 --> 00:31:07,100
was 3. So the next time it is 3. So when I take 3, it is nothing but 12, 36 by 3.

344
00:31:07,400 --> 00:31:13,240
Because 3 into 12 will be 36. The next time when I take 4, it is 4 into 9. The next time

345
00:31:13,240 --> 00:31:20,400
when I take 6, it is 6 into 6. Next time, the next factor is actually 9. And then

346
00:31:20,400 --> 00:31:26,220
you multiply it with 4. The next factor is 12 and you multiply it with 3. And the

347
00:31:26,220 --> 00:31:32,160
next factor is 18. You multiply it with 2. And the next time it is 36, you multiply

348
00:31:32,160 --> 00:31:40,880
it with 1. So if I have to write all the factors, these are all the

349
00:31:40,880 --> 00:31:49,160
factors. Right? But do you have a bit of observation? If I draw a line at this

350
00:31:49,160 --> 00:32:01,220
portion, if I draw a line at this portion, and I take this and I take this, aren't they

351
00:32:01,220 --> 00:32:10,180
equal? 1 into 36, 36 into 1. So can I say, even if I consider everything before the

352
00:32:10,180 --> 00:32:20,820
orange line, I will get 1, I'll get 2, I'll get 3, I'll get 4, I'll get 6, I'll get 9,

353
00:32:21,460 --> 00:32:28,100
I'll get 12, I'll get 18, and I'll get 36. Even if I take everything before the orange

354
00:32:28,100 --> 00:32:33,940
line, even if I take everything before this orange line, do I get all the facts? I do.

355
00:32:33,940 --> 00:32:40,300
So do I need to go beyond this orange line? No. So what is this orange line? If you

356
00:32:40,300 --> 00:32:45,960
carefully observe, what are you doing? A small number into a big number, a small

357
00:32:45,960 --> 00:32:51,300
number into a big number, a small number into a big number, same number, same

358
00:32:51,300 --> 00:32:59,120
number. And then a big into small, a big into small, a big into small. Can I say,

359
00:32:59,120 --> 00:33:05,140
this is nothing but the square root of n, because when you take square root of n,

360
00:33:05,700 --> 00:33:11,740
square root of 36 is 6. Beyond square root, the numbers will grow, the numbers

361
00:33:11,740 --> 00:33:16,420
will grow, and it is nothing but a replication of the upper half, the

362
00:33:16,420 --> 00:33:22,120
replication of the upper half. So thereby, this is nothing but a repetition of the

363
00:33:22,120 --> 00:33:28,060
upper half. Thereby I can say, even if you loop till square root of n, even if you

364
00:33:28,060 --> 00:33:33,540
loop till square root of n, you actually can get your factors. How? If this is 1,

365
00:33:34,080 --> 00:33:40,520
this has to be n by 1. If this is 2, this has to be n by 2. If this is 3, this has

366
00:33:40,520 --> 00:33:46,280
to be n by 3. If this is 4, this has to be n by 4. If this is 6, this has to be n

367
00:33:46,280 --> 00:33:51,800
by 6. So can I say, now the looping is going to be very straightforward. I loop

368
00:33:51,800 --> 00:34:00,440
from i equal to 1 till i less than equal to square root of n and i plus plus. Can I do that?

369
00:34:00,960 --> 00:34:08,860
And can I say, if n modulo i is a factor, then print i as one of the factors,

370
00:34:09,600 --> 00:34:14,260
print i as one of the factors. What is the other factor? We just now found out

371
00:34:14,260 --> 00:34:18,780
the other factor was n by i. But we need to be careful. What is the careful

372
00:34:18,780 --> 00:34:24,460
observation? If it is 6, the other factor might be 6. They are not two different

373
00:34:24,460 --> 00:34:29,080
factors. So if you're taking the second factor, if you're taking the second

374
00:34:29,080 --> 00:34:34,760
factor to n by i, just make sure that n by i is not equal to i. Because the

375
00:34:34,760 --> 00:34:39,420
second factor might turn out to be the same factor. It's very important. The n by

376
00:34:39,420 --> 00:34:43,600
i, which is the second factor, must be compared with i. And if they're not same,

377
00:34:43,600 --> 00:34:52,720
you can say that, maybe print, that's your another factor. That's it. So first, check

378
00:34:52,720 --> 00:34:59,860
if i is a factor, print it. Now the other factor, n by i, with which the i will be

379
00:34:59,860 --> 00:35:05,720
multiplied, just check if this is not equal to i. If it is not, that's the

380
00:35:05,720 --> 00:35:10,680
second factor. That's it. So if you go ahead and print this, the printing will

381
00:35:10,680 --> 00:35:16,340
be something like this. First 1 and 36 will get printed. Next 2 and 18 will get

382
00:35:16,340 --> 00:35:24,180
printed. Next 3 and 12 will get printed. Next 4 and 9 will get printed. Next one i is 6.

383
00:35:24,740 --> 00:35:30,340
6 gets printed, but the other factor is 6. And it fails this condition check.

384
00:35:30,680 --> 00:35:35,600
Thereby, the other 6 doesn't get printed. So all the factors are printed, but

385
00:35:35,600 --> 00:35:41,700
they're not printed in a proper, yes, they're not printed in a sorted way. So

386
00:35:41,700 --> 00:35:46,480
what you can do is, whenever you are getting all the factors, probably you can

387
00:35:46,480 --> 00:35:51,940
store them into a data structure. And if you have seen the C++ STL video, you know

388
00:35:51,940 --> 00:35:57,460
which data structure you can use. You do not know what will be the size or what

389
00:35:57,460 --> 00:36:02,340
will be the number of factors. The data structure that you will be using is a

390
00:36:02,340 --> 00:36:09,600
list, a list in Java or a vector in C++. You'll be using an undefined, like you

391
00:36:09,600 --> 00:36:14,320
cannot define the size of the data structure. We'll be using a list, okay. And

392
00:36:14,320 --> 00:36:18,780
in that list, you can store it, you can store it, store, store, store. So

393
00:36:18,780 --> 00:36:23,880
everything will be stored in the list. Once you have stored in the list, sort

394
00:36:23,880 --> 00:36:28,620
the list. And if you sort the list, you will get everything in the sorted

395
00:36:28,620 --> 00:36:33,240
fashion. So if I go back to the code, what did I say? We will be going till

396
00:36:33,240 --> 00:36:38,460
square root of n, right. We will be going till square root of n. We know this is a factor.

397
00:36:39,040 --> 00:36:43,920
And we need a list now. So let's take a list. This is our list, vector. And we

398
00:36:43,920 --> 00:36:50,540
know ls.push back of i, we push back i. And we know the other factor is

399
00:36:50,540 --> 00:36:56,140
n by i. If this is not equal to i, that's the other factor. Again, we will say list

400
00:36:56,140 --> 00:37:00,260
Can you store the other factor? The other factor is n by i. Once you have stored

401
00:37:00,260 --> 00:37:08,480
everything, can you go ahead and say over here, sort ls.begin, ls.end. Once you

402
00:37:08,480 --> 00:37:12,960
have done this, just need to print it. You know how to print it. This is how you

403
00:37:12,960 --> 00:37:20,620
print the list. C++ STL video guys. So I'll just iterate on the list and I'll

404
00:37:20,620 --> 00:37:25,920
print the list with space. So all of them are correct. I'll go ahead and print and

405
00:37:25,920 --> 00:37:30,500
it will be correct. Why did I sort it? Because they wanted us to print

406
00:37:30,500 --> 00:37:34,340
everything in the sorted order. It's very important to sort the list. If I talk

407
00:37:34,340 --> 00:37:38,460
about the time complexity, what will be the time complexity? Something before

408
00:37:38,460 --> 00:37:41,920
discussing the time complexity, you're writing i less than equal to square root

409
00:37:41,920 --> 00:37:47,000
of n. Instead of this, because square root is a function, and every time the

410
00:37:47,000 --> 00:37:51,580
function will be called, because square root is a mathematical function in C++

411
00:37:51,580 --> 00:37:56,180
STL. This will be called every time, which will take time itself. Instead of

412
00:37:56,180 --> 00:38:01,280
writing this, you can actually write i into i lesser than equal to n. It will be

413
00:38:01,280 --> 00:38:08,680
like when i reaches 6, it will be like 6 into 6 lesser than equal to 36. It will

414
00:38:08,680 --> 00:38:16,400
work. But normally it goes to 7. 7 into 7 is not equal to 36. So this will be false.

415
00:38:17,180 --> 00:38:21,480
Alright. So this is the other way of writing for the square root. This is

416
00:38:21,480 --> 00:38:26,740
what you can write. So can I say this loop is running for, we go off square

417
00:38:26,740 --> 00:38:31,680
root of n times. Can I say this? That this loop is running for, we go off square

418
00:38:31,680 --> 00:38:36,340
root of n times. And then the number of factors, whatever is the number of factors,

419
00:38:36,780 --> 00:38:41,920
you're sorting it. The internal sorting function takes n log n. What is the

420
00:38:41,920 --> 00:38:47,780
internal sorting function taking? n log n. What is n? n is the number of

421
00:38:47,780 --> 00:38:53,520
factors. n is the number of factors. Right? So can I say n is the number of

422
00:38:53,520 --> 00:38:58,040
factors. n is not the original n. It is the number of factors. And then you're

423
00:38:58,040 --> 00:39:02,840
going ahead and printing it. So again, taking a number of factors time to print

424
00:39:02,840 --> 00:39:07,540
it, whatever is the number of times. So the overall time complexity in this case

425
00:39:07,540 --> 00:39:14,240
is we go off square root of plus we go off number of factors into log of number

426
00:39:14,240 --> 00:39:24,300
of factors. So number of factors into log of, if I write it properly, number of

427
00:39:25,380 --> 00:39:32,140
factors. Got it? And then plus this. So we go off this plus we go off this plus we go

428
00:39:32,140 --> 00:39:36,500
off this is the time complexity. But the motive was to teach you that you can

429
00:39:36,500 --> 00:39:42,540
also find factors in we go off square root of n. Got it? I can say I've also

430
00:39:42,540 --> 00:39:46,820
done print all divisors in both the ways. Now what is the next question? It

431
00:39:46,820 --> 00:39:52,080
states check for prime. So what is the definition of a prime number? A lot of

432
00:39:52,080 --> 00:39:57,380
you will say a number that is divisible by one and itself. This is a wrong

433
00:39:57,380 --> 00:40:02,480
definition. Why? Because according to this definition, one is a prime number.

434
00:40:02,700 --> 00:40:06,860
Because one is divisible by one and one is divisible by itself, which is one.

435
00:40:07,180 --> 00:40:11,600
It's a wrong definition. Instead of this, the definition that you should always

436
00:40:11,600 --> 00:40:20,600
keep in mind is a number that has exactly two factors, one and itself.

437
00:40:20,940 --> 00:40:26,000
That's a better definition. One and itself. A number that has two factors, which is

438
00:40:26,000 --> 00:40:33,540
one and itself. So if you remember, we just now computed factors. So if you're

439
00:40:33,540 --> 00:40:39,320
given a number, something like 11. Can I say 11 has a factor of 1 and 11 itself?

440
00:40:39,780 --> 00:40:45,420
Any other number doesn't divide. So 11 is a prime number. If I say 13, 13 is a

441
00:40:45,420 --> 00:40:50,480
prime number because 1 and 13 divides it. If I say 5, 5 is a prime number because 1 and 5

442
00:40:50,480 --> 00:40:57,180
divides it. If I say 4, 4 is not a prime number. Why? Because it is divisible by 1.

443
00:40:57,760 --> 00:41:01,960
It is divisible by 2. It is also divisible by 4. So there are three

444
00:41:01,960 --> 00:41:06,700
factors. So 4 is not a prime number. If I take 8, it is not a prime number. Why?

445
00:41:06,700 --> 00:41:13,520
Divisible by 1, 2, 4, 8 is not a prime number. Something like 17 is a prime number

446
00:41:13,520 --> 00:41:20,740
because divisible by 1 and 17. So what is the first? The brute force. What is the

447
00:41:20,740 --> 00:41:25,680
definition of brute force? The algorithm which is the first algorithm or the

448
00:41:25,680 --> 00:41:32,500
initial algorithm that comes to your mind. Okay. So can I say the simplest way

449
00:41:32,500 --> 00:41:38,840
to check is I will do one thing. I'll keep a counter equal to zero and I know

450
00:41:38,840 --> 00:41:46,140
it exactly has two factors. So run a loop from 1 and I'll go on till n and I'll

451
00:41:46,140 --> 00:41:51,680
say I plus plus and I'll say hey listen if it is a factor it will be completely

452
00:41:51,680 --> 00:41:57,540
divisible by I. Hence it will leave a remainder zero and I'll do a counter

453
00:41:58,040 --> 00:42:04,340
plus plus and can I say at the end of the day if the counter turns out to be

454
00:42:04,340 --> 00:42:09,840
two then I'll say it's a prime number or else it's not a prime number. So can I

455
00:42:09,840 --> 00:42:15,960
say this is the extreme brute force approach and if I write the extreme

456
00:42:15,960 --> 00:42:20,400
brute force approach what will be the time complexity of the extreme brute

457
00:42:20,400 --> 00:42:25,140
force approach? Can I say I'm running a loop n and these are unit operations so

458
00:42:25,140 --> 00:42:30,040
I can ignore. So can I say the time complexity will be b go of n because I'm

459
00:42:30,040 --> 00:42:34,580
running a loop to check for every I which can be a factor and then I'm

460
00:42:34,580 --> 00:42:38,960
checking it and there is and after that there are conditional checks which are

461
00:42:38,960 --> 00:42:45,000
unit operations can be avoided. So this is b go of n and we know that factors

462
00:42:45,000 --> 00:42:50,660
are involved. In the previous problem we did learn that all the factors can be

463
00:42:50,660 --> 00:42:56,300
found in square root of n. Why? Because if you remember 36, 36 had a factor one

464
00:42:56,300 --> 00:43:01,760
and the corresponding factor like the corresponding other factor was 36. 2's

465
00:43:01,760 --> 00:43:11,340
18, 3's 12, 4's 9 and 6 6. Even if you checked till square root of n you could

466
00:43:11,340 --> 00:43:19,800
actually count all the factors and all the factors were 1 2 3 4 6 9 12 18 36 you

467
00:43:19,800 --> 00:43:26,800
can count all the factors. Even if you loop till square root of n. So why are you

468
00:43:26,800 --> 00:43:32,220
looping till b go of n? Kindly loop till square root of n. So what you'll do is

469
00:43:32,220 --> 00:43:37,620
you'll say I equal to 1 I into I lesser than n I've already taught you this and

470
00:43:37,960 --> 00:43:45,320
counter equal to 0 and you'll say if n modulo I is equal to equal to 0 that is

471
00:43:45,320 --> 00:43:51,260
definitely a factor and at the same time the other factor has to be different and

472
00:43:51,260 --> 00:43:57,460
if the other factor is different then it will also be counted and then you can

473
00:43:57,460 --> 00:44:04,160
have a same check if counter is equal to equal to 2 prime else not a prime number

474
00:44:04,160 --> 00:44:10,650
as simple as that and if I talk about the time complexity this loop ends up

475
00:44:10,650 --> 00:44:15,950
running for b go of square root of n if someone is coming up and asking you how

476
00:44:15,950 --> 00:44:20,090
do you check for a prime number you say I know the square root method because I

477
00:44:20,090 --> 00:44:24,290
know the observation for every factor there is the other corresponding number

478
00:44:24,290 --> 00:44:29,070
with which it has to get multiplied in order to get the number thereby I can

479
00:44:29,070 --> 00:44:33,290
just go up to square root of n nothing beyond it because till square root of n

480
00:44:33,290 --> 00:44:38,490
I'll get all the factors. So this is the code that I did right in the iPad so

481
00:44:38,490 --> 00:44:42,550
I'll now quickly go ahead and submit this and see if it is working fine. It is indeed

482
00:44:42,550 --> 00:44:48,230
working fine. So we have completed the check for prime. So apparently you have

483
00:44:48,230 --> 00:44:53,670
completed everything and the GCD or the HCF is left. So let's go across and learn

484
00:44:53,670 --> 00:44:58,670
the GCD or HCF and then come back and take it over. So what do you mean by GCD

485
00:44:58,670 --> 00:45:05,610
or HCF? It's very simple. Greatest common divisor or highest common factor. Let me

486
00:45:05,610 --> 00:45:11,010
give you an example. If I give you two numbers n1 equal to 9 and n2 equal to 12

487
00:45:11,010 --> 00:45:15,850
you need to find the highest common factor or greatest common divisor that

488
00:45:15,850 --> 00:45:22,690
actually divides n and that divides 9 and 12. So if I write down all the factors

489
00:45:22,690 --> 00:45:35,330
of 9 it is 1, 3 and 9. If I write down all the factors of 12 it is 1, 2, 6 and 12.

490
00:45:35,330 --> 00:45:43,710
Even 3, 4. These are all the factors of 12. So if I ask you the common factors, the

491
00:45:43,710 --> 00:45:50,810
common factors if I go ahead and mark it is 1, 1, it is 3, 3. So there are two common

492
00:45:50,810 --> 00:45:56,470
factors. Out of these two common factors which is the highest one 3. So I can say

493
00:45:56,470 --> 00:46:04,350
the GCD of 9, 12 is 3 because 3 is the largest number that divides 9 and 12

494
00:46:04,350 --> 00:46:12,150
both. If I ask you the GCD of 11 and 13 what will it be? It will be 1. Because if

495
00:46:12,150 --> 00:46:16,750
you try to write down all the factors of 11 it's going to be 1 and 11. All the

496
00:46:16,750 --> 00:46:24,070
factors of 13, 1 and 13. So the common one is just 1 and that is the GCD. So there

497
00:46:24,070 --> 00:46:29,010
will always be a GCD because 1 is a number that divides every other number.

498
00:46:29,010 --> 00:46:35,470
So for every given two numbers there will always be a GCD or HCF. If I ask you

499
00:46:35,470 --> 00:46:43,910
what is the GCD of 20, 30 or rather 20, 40. What is the GCD of 20, 40?

500
00:46:44,690 --> 00:46:51,330
Because for 20, 20 is a factor and for 40, 20 is also a factor. So that's why 20. So

501
00:46:51,330 --> 00:46:56,710
for two given numbers one of them can also be a GCD of those two given numbers.

502
00:46:56,710 --> 00:46:59,790
So that is what is the definition of GCD.

503
00:47:11,290 --> 00:47:17,370
So all of you know, so you know how to find factors of two given numbers. A given

504
00:47:17,370 --> 00:47:23,070
N1 and a given N2. So in the last two problems you have learned how to find

505
00:47:23,070 --> 00:47:33,390
factors. So imagine it's like N1 is 9 and N2 is 12. So can I say if I loop from

506
00:47:33,390 --> 00:47:41,750
1 to 12 and for every number I'll check if they're dividing both. Does 1 divide

507
00:47:41,750 --> 00:47:49,470
both? Yes. 1 as of now is the largest factor. Does 2 divide both? No. Does 3 divide

508
00:47:49,470 --> 00:47:55,710
both? Yes. So 3 is the largest factor. If I can check every number and if every

509
00:47:55,710 --> 00:48:00,730
number divides both of them, if a number divides both of them I just replace that

510
00:48:00,730 --> 00:48:07,070
with my GCD's answer. The largest number that I get that divides both of them

511
00:48:07,070 --> 00:48:14,700
will be my GCD. If I try to write it, can I write this as i equal to 1? Maybe I

512
00:48:14,700 --> 00:48:23,200
will loop till N1. Maybe. I plus plus and I'll see if N1 modulo i equal to

513
00:48:23,200 --> 00:48:30,080
equal to 0 and then N2 modulo i equal to equal to 0. As of now I know one

514
00:48:30,080 --> 00:48:35,960
thing for sure. Any given two numbers, any given two numbers will always have a

515
00:48:35,960 --> 00:48:43,760
GCD of 1. So GCD will be replaced by i. Can I say this? Because i is starting

516
00:48:43,760 --> 00:48:49,760
from 1, so it goes from 1, then it goes to 2, then goes to 3. So whichever

517
00:48:49,760 --> 00:48:54,580
number divides both of them it just keeps on getting replaced. The last

518
00:48:54,580 --> 00:49:00,260
number which will be stored in GCD will definitely be the largest because i is

519
00:49:00,260 --> 00:49:05,560
moving in the increasing fashion. Very simple. Now you might ask me, but Stryver,

520
00:49:05,560 --> 00:49:16,760
what if N was given as 12 and N2 was given as 9? Then the for loop would have

521
00:49:16,760 --> 00:49:24,880
been running for 12 times. But I know one thing for sure that if i is 10, that 10

522
00:49:24,880 --> 00:49:31,080
will not divide 9. There is no point in checking. So can I say instead of running

523
00:49:31,080 --> 00:49:38,220
till N1, I can actually run it for something like minimum of N1, N2

524
00:49:38,220 --> 00:49:45,720
because I know if I run till minimum of N1, N2 like 9, if I run till 9 that

525
00:49:45,720 --> 00:49:51,660
will suffice. Running 10, 11 doesn't make sense. For example if the number was 20

526
00:49:51,660 --> 00:49:59,340
and 40, if I run till 20 that will work because 20 is the largest factor I can

527
00:49:59,340 --> 00:50:04,600
have. Running it for 21, 22 will not make sense. So can I say I can run the loop

528
00:50:04,600 --> 00:50:11,500
till minimum of N1 command? I can. Thereby, can I say the time complexity will be

529
00:50:11,500 --> 00:50:17,360
we go of minimum of N1, N2 whichever is minimum till that I'll run the loop so

530
00:50:17,360 --> 00:50:21,800
thereby the time complexity is minimum of N1, N2. Now you might have

531
00:50:21,800 --> 00:50:28,780
questions in your head. But Stryver, we are trying to find IS and over

532
00:50:28,780 --> 00:50:34,760
here what are you doing? You're going from 1, 2, 3, 4 and you're checking everyone. But

533
00:50:34,760 --> 00:50:43,420
what if N1 is 20, N2 is 40 and I do the other way. Yes, I do the other way and I

534
00:50:43,420 --> 00:50:51,400
say I'll run it from minimum of N1, N2, I greater than equal to 1, I minus

535
00:50:52,560 --> 00:51:02,060
and I'll say if N1 modulo I equal to equal to 0 and and N2 modulo I equal to

536
00:51:02,060 --> 00:51:09,640
equal to 0, I will print that as my GCD and I'll break and I'll break and you

537
00:51:09,640 --> 00:51:14,600
know what is the task of break? It always breaks out from the outer loop. Not this

538
00:51:14,600 --> 00:51:19,540
is a conditional statement. This is not a loop. For this break which is the loop

539
00:51:19,540 --> 00:51:23,600
that is outside this break, this one. It will break out from this. How does it work?

540
00:51:24,460 --> 00:51:33,380
The minimum of 20, 40 is 20. So 20. 20 modulo 20 equal to equal to 0. Yes. 40

541
00:51:33,380 --> 00:51:41,040
modulo 20 equal to equal to 0. Yes. Print GCD as 20. Yes. Break. So the program

542
00:51:41,040 --> 00:51:46,620
terminates. In this way you will say, in this way it will have a better complexity

543
00:51:46,620 --> 00:51:51,440
because the moment you are getting someone from behind, it breaks out. You

544
00:51:51,440 --> 00:51:56,640
might give me this. Yeah, definitely this might turn out to be a better one for a

545
00:51:56,640 --> 00:52:03,180
lot of cases but still the worst case will be minimum of N1, N2.

546
00:52:03,920 --> 00:52:10,560
Imagine I give you two numbers. N1 equal to 11, N2 equal to 13. In this case what

547
00:52:10,560 --> 00:52:16,380
will happen? For 11 and 13, the highest common factor is 1. It will start from

548
00:52:16,380 --> 00:52:23,660
11, 10, 9 but will not find anyone till 1. It will eventually loop from 11 to 1.

549
00:52:24,220 --> 00:52:29,540
So no matter what you do, the time complexity will be still this because if

550
00:52:30,040 --> 00:52:35,780
both the numbers have GCD as 1, it ends up running completely. The loop ends up

551
00:52:35,780 --> 00:52:39,740
running completely and you know when you determine the time complexity, taught you

552
00:52:39,740 --> 00:52:44,520
in the time complexity lecture, you always take worst case. You always take

553
00:52:44,520 --> 00:52:50,100
worst case. The worst case is when you run it till 1. We saw the previous

554
00:52:50,100 --> 00:52:54,160
method was a brute force method and was taking linear time complexity. Now there

555
00:52:54,160 --> 00:52:59,480
is an algorithm known as eucalydian algorithm which is going to take much

556
00:52:59,480 --> 00:53:04,580
much lesser time. So let's learn about it. So what is eucalydian algorithm? It

557
00:53:04,580 --> 00:53:12,960
states if we're given two numbers N1, N2, the GCD of N1, N2, whatever is

558
00:53:12,960 --> 00:53:24,600
the GCD of N1, N2, that's equivalent to the GCD of N1 minus N2, N2, where N1

559
00:53:24,600 --> 00:53:31,760
is greater than N2. Usually in books you'll find them written as GCD of A, B

560
00:53:31,760 --> 00:53:39,280
is equal to GCD of A minus B, B where A is greater than B. This is what the

561
00:53:39,280 --> 00:53:44,280
eucalydian algorithm states. If you want a mathematical proof of it, you can

562
00:53:44,280 --> 00:53:49,540
definitely Google search. There's a huge mathematical proof to it. Again we will

563
00:53:49,540 --> 00:53:53,560
not go deep into the mathematical proof because it is not required in

564
00:53:54,060 --> 00:53:59,220
programming world. You just need this concept. So just have the concept. Now if

565
00:53:59,220 --> 00:54:04,120
I try to prove this with induction it's very simple. If I give you two numbers

566
00:54:04,120 --> 00:54:10,400
imagine 15 and 20. So it basically states the greater number and the

567
00:54:10,400 --> 00:54:16,300
smaller number. What is the GCD of 20, 15? We know the GCD of 20, 15 is 5.

568
00:54:17,020 --> 00:54:21,420
So it states the GCD of 20, 15, the greater number 20 and the smaller

569
00:54:21,420 --> 00:54:29,820
number 15 is equal to, it states greater minus smaller, 20 minus 15, 5, the

570
00:54:29,820 --> 00:54:35,600
smaller number 15. So what is the GCD of 5, 15? That is also 5. So again by

571
00:54:35,600 --> 00:54:39,160
induction also you can prove it. You can take any two numbers and you'll be able

572
00:54:39,160 --> 00:54:45,660
to prove that they are same. So I can say that the GCD of 20, 15 is

573
00:54:45,660 --> 00:54:53,280
equivalent to the GCD of 5, 15. Now you apply the eucalydian on the first two

574
00:54:53,280 --> 00:54:59,240
numbers and whatever you get that will always be a truncated number. You saw 20

575
00:54:59,240 --> 00:55:07,340
getting truncated to 5. Again you will apply eucalydian to this. If you try to apply

576
00:55:07,340 --> 00:55:12,540
eucalydian to 5, 15 it has to be the greater number at first. So apparently

577
00:55:12,540 --> 00:55:17,760
you have to apply eucalydian to 15, 5 because 15 is the greater number.

578
00:55:18,260 --> 00:55:22,020
Right? So what do you do is you say okay let's apply eucalydian to 15, 5.

579
00:55:22,020 --> 00:55:31,000
It will be like GCD of 15 minus 5, 10, 5. Again you can apply eucalydian to 10, 5.

580
00:55:31,000 --> 00:55:37,140
If you apply eucalydian to 10, 5 it will be greater is 10, 10 minus 5 is 5, 5, 5.

581
00:55:37,780 --> 00:55:43,420
Again if you apply eucalydian to 5, 5 it'll be, both of them are same,

582
00:55:43,580 --> 00:55:49,880
any one can be at the front, 0, 5. So 1 apparently becomes 0. The moment

583
00:55:49,880 --> 00:55:56,840
one of the numbers becomes 0, the other number is actually a GCD, is actually a

584
00:55:56,840 --> 00:56:02,640
GCD. So the GCD of 20, 15 is this. What do you do is you take two numbers, apply

585
00:56:02,640 --> 00:56:06,960
eucalydian, get it smaller, apply eucalydian, get it smaller, get it smaller, get it

586
00:56:06,960 --> 00:56:11,980
smaller till one of them is 0. If one of them is 0, the other is 0. So the

587
00:56:11,980 --> 00:56:19,860
algorithm is quite simple. Start with a, b, keep on truncating, keep on

588
00:56:19,860 --> 00:56:26,180
minus b, b and keep on doing till one of them, the greater number becomes 0.

589
00:56:26,780 --> 00:56:31,620
As simple as that. But there's a catch. This might end up taking a lot more time.

590
00:56:32,380 --> 00:56:39,700
Imagine I give you a number like a equal to 52 and b equal to 10. So it'll be like

591
00:56:39,700 --> 00:56:49,360
what will you do? You will say GCD of 52, 10 truncated to GCD 42, 10.

592
00:56:49,360 --> 00:56:58,920
Truncated to GCD 32, 10. Truncated to GCD 22, 10. Truncated to GCD 12, 10.

593
00:56:59,340 --> 00:57:05,620
Truncated to GCD 2, 10. And then you again take the bigger number at first,

594
00:57:06,140 --> 00:57:11,020
10, 2. And then you'll be again like truncated to 8, 2. Truncated to

595
00:57:11,020 --> 00:57:17,880
6, 2. 4, 2. 2, 2 and 0, 2. And ultimately 2 is left because

596
00:57:17,880 --> 00:57:23,660
everything comes up. So it's a lot of sticks. It's a lot of sticks. It might not improve the

597
00:57:23,660 --> 00:57:29,280
linear complexity by so much. But there's a catch over here. If it is 52 and it was 10

598
00:57:29,280 --> 00:57:36,140
and you're reducing it with 10 every time and you ended up at a place of 2, 10.

599
00:57:36,780 --> 00:57:45,220
Isn't it equivalent to saying you're dividing it by 10? And you're like 52, if you

600
00:57:45,220 --> 00:57:52,920
did it 5 times. 1, 2, 3, 4, 5. And you ended up having the remainder because you're

601
00:57:52,920 --> 00:57:57,960
minus 10, minus 10, minus 10, minus 10 till it is possible. It's equivalent to saying you

602
00:57:57,960 --> 00:58:04,840
subtract it till it was possible or till it is greater. Can I say, instead of

603
00:58:04,840 --> 00:58:10,640
subtracting it 5 times, you could have directly gone from here to here by

604
00:58:10,640 --> 00:58:19,700
saying 52 modulo 10, 10. That's same. 2, 10. That is same instead of

605
00:58:19,700 --> 00:58:25,880
subtracting 10, 5, 10. Directly get 2, 10. Even from 10, 2 to 0, 2, you

606
00:58:25,880 --> 00:58:29,640
could have directly gone by saying 10 modulo 2 because that is what you did

607
00:58:29,640 --> 00:58:35,820
indirectly. Simple maths. So can I say the algorithm in a better sense will be GCD

608
00:58:35,820 --> 00:58:42,460
of A, B, where definitely A is greater than B, is equal to A modulo B, B.

609
00:58:42,760 --> 00:58:49,580
That's a better word. And you go on doing till it becomes 0. As simple as that. You always take the

610
00:58:49,580 --> 00:58:55,300
greater number. So the logic is very simple. Forget about A and B. The logic is very

611
00:58:55,300 --> 00:59:03,800
simple. The greater modulo is smaller. That's the logic. And you go on till one of them

612
00:59:03,800 --> 00:59:12,540
is 0. And if one of them is 0, remember this, if one of them is 0, the other is GCD, the

613
00:59:12,540 --> 00:59:26,300
other is GCD. As simple as that. If I try to quote this up, try to quote this up, you're given A, you're given B. Can I say you go on till both of them are greater

614
00:59:26,300 --> 00:59:33,660
greater than 0. Basically. And I know one of them will be greater. Either A will be greater. In that

615
00:59:33,660 --> 00:59:43,360
case, I'll do A modulo B. Or else if B is greater, I'll do B modulo A. Instead of swapping, changing, because I did not want to get into swapping, changing. Why?

616
00:59:44,400 --> 00:59:57,600
Over here it was 2, 10. So A was this, B was this. And you swapped it to this. I did not want to implement that. I just, I knew now 10 will be modulated. So what I did was I implemented it in such a way

617
00:59:57,600 --> 01:00:17,860
stating, if A is greater, A will be modulated. If B is greater, B will be modulated. And once this is over, if A is 0, if A becomes 0, the while loop is false. Can I say the GCD will be B? I will. Or else can I say the GCD will be print of A? Simple.

618
01:00:19,760 --> 01:00:32,620
Yes. You can, you can just take this example, 52, 10, and you can do a dry run on this. And you will see that eventually one of them will become 0. And that is when the looping ends.

619
01:00:32,620 --> 01:01:02,460
And the time complexity of this equilaudian algorithm is we go of log of phi minimum of A, B. While log, if you remember, I clearly stated during the digit extraction, or in the pattern videos, or the time complexity videos, that whenever there is division happening, whenever there is division happening, the number of iterations will be in terms of logarithm.

620
01:01:02,620 --> 01:01:31,340
Over here there is modulo. You are reducing the number by division. The modulation operations are happening. Thereby the time complexity will be in terms of logarithm. Now, Wi-Fi, why not something like log base 10? In the digit extraction, it is always n by 10. Over here, this A and B, it's always changing, fluctuating. You're not sure what will be A and B. Depending on different examples, it will fluctuate.

621
01:01:31,340 --> 01:02:01,100
That is why they're giving it a term phi. If you want to know what is phi in depth, there's a huge mathematical proof to it. Not required. You can read it, but it's not required. And minimum of A, B. Because that is the initial number where you start from. That's the initial number where you start to do it. So that's why the time complexity is this. No one is going to ask you how and everything. Just keep it in mind that the time complexity is log phi minimum of A, B.

622
01:02:01,340 --> 01:02:02,020
This is the equivalent.

623
01:02:03,980 --> 01:02:21,700
I've written the same code after if I'm not given else because if this line executes, the function would have end and this line will not execute. That's why. So now I'll go ahead and run this code and it is running absolutely fine. And if I'll submit this, we get the correct answer.

624
01:02:21,700 --> 01:02:31,640
So with this, we'll be wrapping up the basic maths. Next is basic recursion. I've already made videos on it. I'll be attaching them to the playlist. So watch this maths video.

625
01:02:32,180 --> 01:02:43,640
Who's that going towards the basic recursion video. Once you have done this, then we will be going across to the next topic. That is basic hashing and I'll be explaining hashing in depth.

626
01:02:43,640 --> 01:02:57,200
But I hope for this video, you've understood basic maths completely just in case you have. Please hit that like button and to follow our ritual, do comment understood so that I get an idea that you guys are understanding and you have watched the video.

627
01:02:57,620 --> 01:03:10,100
Till here, if you're new to our channel, what are you? Please, please do consider subscribing to us because that is the only thing that keeps me motivated to make these kind of content. And here with this, I'll be wrapping up this video. Let's be in some other video till then goodbye.

628
01:03:14,380 --> 01:03:17,080
Don't ever forget your gold.

