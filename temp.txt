{
    "text": " Hey everyone, welcome back to the channel. I hope you guys are doing extremely well. So this video is going to be another video from the strivers A2Z DSA course. And this is India's most in-depth DSALGO course. Why do I see that? Because this course has 455 modules. I can guarantee you that you can take any paid batches, any free courses. None of those courses will have 455 modules. This is an extremely in-depth DSALGO course that can teach you. everything in breadth about DS Algo. And in the previous videos, we have covered step 1.1 and 1.2. And regarding step 1.3, I've added a video on C++ STL on the playlist. You can go and watch it. Regarding Java collection, I'll be adding a video in the future, not now. If you need a video now, you can go to YouTube and you'll find a lot of other resources from where you can study. So in this video, we will be discussing about basic maths. Why am I teaching just the basic maths as of now? So you're starting off as of now. Your brain will not be that matured. So if I teach you the advanced level concepts, you might understand, but it won't be that convenient for you. That is why my teaching way is very different. What I do is I usually start off with the basic stuffs. I give you a lot of time to absorb it. And then we move on to the advanced part. This is why all the basic stuffs are initially there. And then we move on to the DSALGO. And in the step 8, we have a section as advanced mathematics. we'll be covering everything that is related to advanced mathematics that might be asked in interviews. But as of now, we will be learning basic maths. Now, these are the problems which we will be solving. But before that, let's learn some basic maths concept. So before solving all the problems that are listed under basic maths, we'll be starting off with the basic maths concept. I'll be teaching you the concepts initially and then we can solve all the problems listed under the section. The first concept that I'll be teaching you is the digit concept. Remember one thing. This is a very, very important concept. Because if you know how to play around digits, then you'll be able to solve most of the problems in basic maths. Let's understand the digit concept. Imagine I give you a number like 7-7-8-9. This is the number that I'm giving you. Now, I ask you to perform extraction of digits. I ask you to perform extraction of digits. Let's learn the extraction of digits. And after that, you will see how we can implement the extraction of digits in order to solve most of the problems. So when I say extraction of digits, what does it mean? It means, I need nine, I need eight, I need seven, I need seven. I need all the digits individual. So what is this digit? Nine. Can I see this? If I do a module 10, I'll actually get 9. You might ask why. If I ask you, the numbers that are divisible by 10, what are they? 10, 20, 30, 40, 50, 60, 70, so on, 100 and so on. Do you see a pattern? All the numbers that are divisible by 10 are actually ending with 0, is it? Right? So, can I say, if I'm doing a module 10, what is the meaning of modular operator? in basic max. The module operator says, I will divide the number by 10 and whatever is the remainder, that is what I'll give you. So if I say, if I'm dividing this number by 10, what is the nearest number? Obviously that will be 7, 7, 8, 0. If I divide it by 10, this is what the nearest number will be. And can I say that the remainder then will be 9? Because if I divided by 10, then this is where the division, like this is the number which which will get divided by 10. And after that we'll be left out with 9. That is why when you do a module 10, you always get the last digit. You get the last digit as 9. So this is how you get the 9 digit. If I ask you, can I get the next digit 8? How will you get the next digit 8? Very simple. You say, okay, this number, let's divide it by 10. So if I divide 7, 7, 7, 8, 9 by 10, can I say I'll get 7, 7, 778.9. Can I say this? If I divide the number 7789 by 10, I'll get 778.9. And if I take an integer round of, if I take an integer portion of it, the integer portion is 7.78. So what you will do is, in order to go to the next step, you will say divide by 10. If you do your division by 10, you'll actually get 778.9, but you just take the integer part. That is why you get 778. So once you have 778 with you, if I need the last digit, which is 8, how do you extract it? Again, the same way. You see, can I divide modularize with 10? If I do a mod of 10, I'll actually get 8. Why? Because the nearest number will be 770, which is divisible by 10, which will still leave a remainder of 8. So I get the digit 8 as well. Now, can I see if I require the next digit 7? can I again do a division by 10? If I do a division by 10, can I say I'll get 77? Why? Because if I write 778 by 10, I'll get 77.8 and the integer portion is 77. So I get 77. Again, if I have to extract the last digit, can I say I'll do a modular rise, a modulo of 10, and I'll get 7. I will. Hence, I have again extracted 7. Now, if I need the next extraction, I again divided by 7, so I divided by 10, and I'll get 7 because 77 divided by 10 is 7.7 and the integer part is 7. So I get 7. If I do a modularize of 10, I'll actually again get 7. Why will you get again 7? Very obvious because the nearest number that is divisible by 10 to 7 is 0. thereby you get a remainder of 7 so you get 7 after that if you again try to divide it by 10 this time you'll end up getting 0 because if I take 7 divided by 10 it will be 0.7 as the integer part is 0 so can I see if I get an integer part is 0 can I say I've extracted all the digits I have and if you see the extraction has been done in the reverse order and all the digits have been extracted as simple as that so this is how you can easily extract all the digits so if i try to write the pseudo code how will the pseudo code look like can i say if i have the n i can take take it from the user i can take the end from the user and imagine i'm asking you to print all the digits extract all the digits like nine eight seven seven and you can print it so how will you do it it's very simple i will be like okay while i know what is the last step last step is the extraction goes on from n when it is 7-789 to n till 0. So I'll be like, I'll go on till n is greater than 0, which means till n doesn't becomes 0, right? And can I see the extraction is very simple. The first time, N was 7-789. If I had to do an extraction, it's very simple. Can I say the last digit is nothing but N modularized 10? If I do an N modularized 10, I'll get the last digit 9. and in order to get the next digit, what I do is I say N is N by 10 and this is how I can do it. So what will happen? Let's do a dry rod. At first, imagine I give the user gives N as 7,789. So this says 7789 greater than 0, which is true. So the last digit happens to be 7789 modularized 10 and the last digit is 9. If you want to print this last digit, you can definitely put a print operation in c plus plus it is c out in java it is system dot out printl so you can go ahead and print the nine once you've done this can i say if you do 7 7 7 8 9 by 10 then the end will reduce itself what will be the value of n now can i say the value of n will be nothing but 7 7 7 8 this is how the first iteration first iteration will happen and then it will reach here then again goes here now when it goes here it will be a new iteration and can I say this time the iteration will be 778 because n has changed itself to 778 and 778 greater than 0 what will do is I'll quickly erase this because it's the next iteration so let's quickly raise this and the next iteration what will happen it will see 778 modularize 10 the last digit this time will be 8 again you can print that last digit and this time it will be 778 by 10 hence Since n will become 77, again the iteration will go and will be 77 greater than 0. And this way, all these steps will be performed at the end of the day, the value of N, yes, the value of the N will be 0. Hence the while loop will be false. And I can say that the execution has been completed and you have successfully extracted all the digits in the reverse fashion. Very important in the reverse fashion. Got it? So this is what is the concept of. extraction of digits and this is going to help you solve a lot of other problems as well. So now let's look at the first problem. It states count digits. Let's understand the problem. Given the number n, find out and return the digits present in a number. Very simple. It says 156 is the number and the number of digits is three. Imagine the N is given as 7. It has just one digit. So it'll be given an N and you'll tell me the number of digits. So if I go back to my iPad, can I say, if I give you the number 7,7, 8, 9, this has 4 digits. Can you solve this problem using the extraction of digits? Can you? You'll be like, this is super easy. Why? Because you know the extraction of digits. You know one digit, 2 digit, 3 digit, 4 digit. The digits are extracted 4 times. So can I say, I can keep something like a counter variable over here? and you know the number of times the extraction happens that is the number of times the digit will be so can I say I can put a counter equal to counter plus one on the logic of extraction of digits if I do this can I say I'll be able to count the number of digits and eventually if I print the count over here can I say that I'll always have the count of digits of any given and I can Usually in coding rounds or in your interviews, you just have to code the function. The function is an int function that means you have to return the count of digits and they'll be giving the input. So you're given the variable. You just have to return. You have to just write the code inside the function. Int main and everything will be written on the backend. I've already discussed about this in the pattern video. In case you haven't watched it, please go back and watch it. So this was the code that we discussed on the iPad. right so the count stores the count of digits so just return the count and then I'll go ahead and run the code and I'll see that it is running absolutely fine and then I'll go ahead and submit this so this is how you can easily solve this particular now remember one thing this last digit does not have any significance so you can remove it so that was for extraction of digits but this is kind of reducing the numbers so the number of times it is divisible by 10 is the number of of times the digits are. Now since I've removed the modular operation, we observe something. Can I say the number of times it is getting divisible by 10, the number of times it is getting divisible by 10 is the count of the digits. It is and this is where something like logarithmic, log base 10, 7,789. If you do this in your calculator, it'll actually get something like 3.89 something. So this is the value that you'll get. if you do a log base 10 of the number and then if you can add a 1 to it this will be 4.89 and if you take an integer of it that will be 4 this is another way to find count of digits what you do is very simple you say count is equal to log 10 the number plus 1 and you're saying take the integer or you can just auto cast it like type cast it to integer this is This is how whatever you get, this is converted to an integer. If we're getting 4.8 time, it'll be truncated to 4. And now let's run this and see if it is running fine. Okay, so it says out of scope. Lock 10 was not declared. So if you find such errors, what you can do is you can go to hash include. That's basically because in their backend, they might not have added all the directories. You can go ahead and add all the directories and that will start working fine. Once you've done this, you can go and compile and you're seeing that. You're seeing this, that this is also running. This is one of the other ways to count digits as well. But the primary concept is extraction of digits, and that is what you should focus on. Now, if I discuss the time complexity over here, what will be the time complexity? The time complexity will be nothing but log base 10. And this is the bigot of time complexity. Why log base 10N? The reason was very simple. You saw this is getting divisible by 10. How many times is the loop running? The number of times it is getting divisible by 10. This is why you will say time complexity is near about log base 10. This was 3.89 near about 4. The number of times this loop did run was 4. Yeah, you can avoid these operations. These are single operations because imagine the number being very large. these will be considered as unit operations. That is why the time complexity is log base 10, n. Whenever there is division, remember this. Whenever there is division, if the division is happening by 10, you say log base 10. If the division is happening by 2, you say log base 2. And if the division is happening by 5, you say log base 5. This is how you compute the time complexity of like, this is how the logarithmic time complexities are. So whenever you're writing a logic where the number of iterations depends on division and you're dividing, dividing, that is when something like logarithmic will come into the time complexity. That time the time complexity will not be ego of n. If the number of iterations is based on division, time complexity will be logarithmic. Remember this always. So you solve the first problem count digits. The next problem is reverse a number. Let's go to the problem. It states write a program to generate the reverse of a given number. Print the corresponding reverse number. If a number has trailing zeros, then its reverse will not include them. For an example, the reverse of 104 will be 401 instead of 0401. And these are some of the examples. So let's get back to our extraction of digits concept. So according to the problem, what they are wanting is if I'm giving you the number 770, 7-7-89, the reverse of this number will be 9-877. Now, we know that the extraction of digits happens in the reverse fashion, where we generate 9, then we generate 8, then we get 7, then we get 7. Somehow, we need 9-877, which is the similar fashion. This is where the basic maths comes in. What do you do is you define a variable sum or maybe reverse number. Reverse number equal to zero. And you say reverse number equal to reverse number into 10 plus last digit. Remember this. This is what you say. Reverse number into 10 plus last digit. Let's see how it works. So I'm saying initially reverse number is 0 to start off. Let's do the step by step. First step, 9 gets generated. So what am I doing is 0 into 10 because reverse number is 0 at the first step. At the first step, 7-789 Moduro 10 will generate 9. And N would have as of now become something like 7-7-8-9 by 10. So n would have as of now become 7, 7, 7, 8. And reverse number says reverse number is 0 into 10 plus the last digit 9. So the number becomes, or rather the reverse number as of now is 9. Right. This is what the first iteration is. Let's do the next iteration. So the next iteration will be, I'll just quickly omit this off. So in the next iteration, can I say it's 778, greater than 0 and 778 Modulo 10 hence the last digit is 8 I can say this and this will be 778 by 10 so N will become 707 this time reverse number is stored as 9 because you stored reverse number as this value so this is 9 so what do you do is you say 9 into 10 plus the last digit 8 so what do you get is 9 into 10 plus the last digit 8, which makes it 98. The next time you get 7, the reverse says 98 into 10 plus 7, which is 98. Next time it is 7, the 987 into 10 plus 7 is 987. So you got the reverse number at that. Why it's simple? Why did this work? It is very easy. Understand. you are getting in last digit you're easily getting the last digit nine and after that you're getting the next last digit eight and you somehow want to add eight to that nine you somehow want to add eight to that nine and the easiest way is if you can somehow add a zero to this nine it will become 90 and then if you add eight to it it will become 98 similarly if you want to add seven to it if you want to add a seven to it make it nine eighty seven you are again again add a 0 and then a 7 to 8 it becomes 987 again if you want to add a 7 you again add a 0 this is why at every step i am doing reverse number into 10 whatever you have generated into 10 that will allow the last unit digit to be 0 then when you add a digit goes and gets into that place as simple as that so again you saw that extraction of digits is actually handy so So what I'll do is I'll take the number and I'll keep the reverse num equal to 0. And then I'll go ahead and say n greater than 0. And I can say last digit is N modulo 10. I can say reverse number is reverse number into 10 plus last digit. And I can say n is n by 10 and the same time I can say C out of reverse number is what I need. Perfect. And I'll quickly run the code and see if it is right. running fine it is let's quickly submit this and this should be running fine this dead so so reverse a number is salt again with the concept of extraction of digits next problem is check palindrom now when I go to the palindrome problem let's understand the problem it states write a program to determine if a given number is palindrome or not print true if it is palindrom or false otherwise so overhead states palindrom are the numbers for which reverse is exactly same as the original one. For an example, one to one. Because if you take one to one and you do a reverse of it, one to one's reverse is one to one. That is why it is called as palindrop. So if I go to the iPad and write some other palindrum numbers, it's like one-double-three-one. If you write the reverse of it, it stays still one-double-three-one. Something like 11. 11 in itself is a palindrop. 7. 7 in itself is a palindrome whereas 1 to 3 the reverse of 1 2 3 to 1 this is not a palindrome so any number which on reversal is the same number is a palindrome number so the definition of palindrome number says reverse of a number so if i somehow can generate the reverse of a number if i somehow can generate the reverse of a number which i've already did and then compare it with the original n if they come out to be same can i say they are palindrome I can. So over here if you remember, we took a reverse number. And at the end of the day, the reverse number was nothing but the reverse number. And now, if I can compare this reverse number with the original number, with the original number, which is N, and if they come out to be same, I can say it as palindrome. Like, if this is true, I can say this palindrome or I can say it is not palan. Can I see that? But wait, wait. If you remember, we were dividing n by 10. and at the end of the day, n was zero. So does N have the original number? No, because we are doing operations with N which has made N to be zero at the end of the day. So what I need to do is maybe I need to store a duplicate of N in some double variable. And instead of comparing it with N, I can compare it with a duplicate because N will p0 at the end of the extraction of digits. It's very important to store a copy of n somewhere so that it can be used to compare it with the reverse of a number. That is the only change that you have to do. That is the only thing that you have to keep in the mind. So if remember this was the code, so what I'll do is I'll just go ahead and say duplicate equal to n and over here I say if dupe is equal to reverse number. I can go ahead and print true, which is what they want, which is true or else. else you can just go ahead and print that is what they required if there's small well quickly run it and see if it is running fine should be and let's quickly submit this on submitting you see that it is running absolutely fine next one is gcd or hcf but before that we will be solving armstrong numbers so what is the definition of armstrong number it's very simple imagine you're given this number 371 you take three cube, 7 cube plus 1 cube. If taking the cubes of these numbers, like cubes of these digits and adding them up, sums up to the number itself, that is what you call as an Armstrong number. Even if you take 1634, 1 cube plus 6 cube plus 3 cube plus 4 cube, if you sum them up, you actually get 1634. But something like 35, if you take 3 cube plus 5 cube, this is not going to be equal to. 35 this is going to be equal to 134 so this and this are not same whereas 1634 and the summation of cubes of its digits is 1634 so you call 1634 as an armstrong number or 371 as an armstrong number so i hope you've got the definition of armstrong number if you have got the definition of armstrong number you know how to solve it i've already taught you the extraction of digits you know how do you extract nine you know how do you extract eight You know how do you extract 7? Just have to do a cube of it. So can I see this time, instead of taking any such duplicate or reverse n, I can just take a summation because I need to sum cubes. And last digit is what I have to sum. Can I say sum equal to sum plus last digit multiplied thrice? Last digit into last digit into last digit. Can I do this? So first time nine comes in. What happens? 9 into 9 into 9 gets added to sum. Next time 8 comes in, 8 into 8 into 8 gets added to the sum. So everything is getting added. First time, 9 into 9, sorry, 9 into 9 into 9 got here. Next time 8 went 8 into 8 into 8. Next time 7 came in, 7 into 7. Next time again 7 came in 7 to 7 into 7. So can I say at the end of the day, some will be storing the summation of digit cubes and after that you need to just compare it with the original end so maybe again keep a duplicate variable which stores the end because at the end of the day you have to compare if this and the duplicate are same if this is then you say it is an arm strong if this is not it's not an arm's again what logic worked extraction of digits if you know how to extract digits You can play around with them and you can solve this problem. So Armstrong number is completed and the next problem that we'll be doing is print all divisors. So when I say print all divisors, what does it mean? Imagine I take a number like 36. Now ask you, what are all the numbers that divide 36? So you can say one is something which completely divides 36. You can say two is something which completely divides 36. You can again say three is something which completely divides 36. 4 is something which completely divides is 5 something which completely divides 36 no if 36 is divided 5 it leaves a remainder of 1 so not 5 6 is something which does it 9 is something which in does it and 12 is something which does it then 18 is something which does it and then 36 is something which does so if I talk about 36 the divisions of 36 are 1 2 3 4 6 9 12 18 and 36. These are the divisors of 36. The question is very straightforward. You have to print all of them in this particular order. Okay? Now, how do I do? It's very simple. One thing I know for sure is, if I'm talking about divisors or factors, they're definitely going to lie between one to the number itself. Can I say all the divisors will be between one to and itself, because anything greater than n will never divide n for sure so if i know all the divisors are going to be between one and n can i just loop from one to n that's my first thought process since i know the divisors are from one to n my first thought process is very simple so let's do one let's start the loop from i equal to one i lesser than equal to n and i plus plus this is something i know for sure So I is used to loop around. Now the first value of I is 1, then it's 2, then it's 3, then it's 4, then it's 5, and then so on till 36. In this case, if it is n. So how do you determine that this I is a part of all the divisions? It's very simple. Can I say if it is completely dividing, if I is completely dividing n, then it is a factor or a divisor? And what do you mean by completely dividing? It should leave a remainder of 0. When I say leaving a remainder of 0, does it mean if I do a modulated of I? If I do N modulo I, the value should be 0 because it's completely divisible. By what I will do is, I'll say, okay, if N modulo I is equal to equal to 0, I will go ahead and print I in C++ plus see out in Java system.com. dot print and I'll go ahead and print out in this way I'll be able to print all the factors of a particular n if I talk about the time complexity ask you what is the time complexity of this code you'll be like striver it's very simple since the loop is running from one to n it's taking n iterations and this is an unit operation so let's not compare calculated thereby the time complexity of this particular approach is nothing but we go off and very Over here they've given us everything. They want us to write this print divisors function. Let's write the print divisors function. It takes an n. And as I said, it's very simple. You go from 1, you go on till n. And you say I, this one. And you know if n modulo i is equal to equal to 0, you say see out, I, and then you give a bit of space. That's what you need to write. And on submitting, you will see that this is running absolutely fine. fine but the time complexity is bgo of n i don't want a bgo of n time complexity can i do it in a much better way i can't but it requires a bit of mathematical observation let's see that mathematical observation so for 36 i said that one was a factor if one is a factor one has to be multiplied with something in order to get 36 so one was multiplied with 30 and if you carefully observe if this is 1 and the number is 36 the other number will always be n by 1 very simple if it is 2 the other number will be n by 2 which is 36 by 2 that means 18 so you get 18 the next time it was 3 so the next time it is 3 it is nothing but 12 36 by 3 because 3 into 12 will be 36 the next time when I take 3 it is nothing but 12 36 by 3 because 3 into 12 will be 36 the next time when I take 4, it is 4 into 9. The next time when I take 6, it is 6 into 6. Next time, the next factor is actually 9 and then you multiply it with 4. And the next factor is 12 and you multiply it with 3. And the next factor is 18, you multiply it with 2. And the next time it is 36, you multiply it with 1. So if I, if I have to write all the factors, these are all the factors. These are all the factors. definitely all the factors right but do you have a bit of observation if I draw a line at this portion if I draw a line at this portion and I take this and I take this aren't they equal 1 into 36 36 into 1 so can I see even if I consider everything before the orange line I will get one I'll get two I'll get three I'll get four I'll get 16 sorry six I'll get 9 I'll get 12 I'll get 18 and I'll get 36 even if I take everything before the orange line even if I take everything before this orange line do I get all the fact I do so do I need to go beyond this orange line no So what is this orange line? If you carefully observe, what are you doing? A small number into a big number. A small number into a big number. A small number into a big number. Same number. And then a big into small. A big into small. A big into small. A big into small. So can I see this is nothing but the square root of n. Because when you take square root of n, square root of 36 is 6. beyond square root, the numbers will grow, the numbers will grow and it will nothing but a replication of the upper half, the replication of the upper half. So thereby, this is nothing but a repetition of the upper half, thereby I can say, even if you loop till square root of n, even if you loop till square root of n, you actually can get your factors. How? If this is 1, this has to be n by 1. If this is 2, this has to be n by 2. If this is 3, this has to be n by 3. If this is 4, this has to be n by 4. If this is 6, this has to be n by 6. So can I say, now the looping is going to be very straightforward. I loop from i equal to 1 till i less than equal to square root of n and i plus plus? Can I do? And can I say if n modulo i is a factor? Then print I as one of the factors. Print I as one of the factors. What is the other factor? We just now found out the other factor was N by I. But we need to be careful. What is the careful observation? If it is 6, the other factor might be 6. So there are not two different factors. So if you're taking the second factor, if you're taking the second factor to N by I, just make sure that N by I is not equal to I. because the second factor might turn out to be the same factor. It's very important. The N by I, which is the second factor, must be compared with I. And if they are not same, you can say that, maybe print. That's your another factor. That's it. So first, check if I is a factor, printed. Now, the other factor, N by I, with which the I will be multiplied, just check if this is not equal to I. If it is not, that's the second factor. That's it. So if you go ahead and print this, the printing will be something like this. First one and 36 will get printed. Next two and 18 will get printed. Next, three and 12 will get printed. Next four and nine will get printed. Next one is six. Six gets printed. But the other factor is six. And it fails this condition check. Thereby, the other six doesn't get printed. So all the fact is six. factors are printed but they are not printed in a proper yes they're not printed in a sorted way so what you can do is whenever you are getting all the factors probably you can store them into a data structure and if you have seen the c++ stl video you know which data structure you can use you do not know what will be the size or what will be the number of factors so the data structure that you will be using is a list a list in charge or a vector in C++. We'll be using an undefined. Like you cannot define the size of the data structure. We'll be using a list. Okay. And in that list, you can store it. You can store it. You can store, store, store, store. So everything will be stored in the list. Once you have stored in the list, sort the list. And if you sort the list, you will get everything in the sorted fashion. So if I go back to the code, what did I say? We will be going till square. root of n right we'll be going to square root of we know this is a factor and we need a list now so let's take a list so this is our list vector and we know ls dot push back of i a push back i and we know the other factor is n by i if this is not equal to i that's the other factor again we'll say list can you store the other factor and the other factor is n by i once you have stored everything can you go ahead and say over here sort LS dot begin, LS dot in. Once you have done this, just need to print it. You know how to print it? This is how you print the list. C++ STL video guys. So I'll just iterate on the list and I'll print the list with space. So all of them are correct. Now go ahead and print and it will be correct. Why did I sort it? Because they wanted us to print everything in the sorted order. It's very important to sort the list. I talk about the time complexity, what will be the time complexity? Something before discussing the time complexity, you're writing I less than equal to square root of n. Instead of this, because square root is a function and every time the function will be called because square root is a mathematical function in C plus plus ST. This will be called every time, which will take time itself. Instead of writing this, you can actually write I into I lesser than equal to 1. It will be like when I reach a 6, it will be like 6 into 6 less than equal to 36. It will work. The moment it goes to 7, 7 into 7 is not equal to 36. So this will be false. So this is the other way of writing for the square root. This is what you can write. So can I say this loop is running for Biggo of square root of n times? Can I say this? that this loop is running for, we go off square root of time. And then the number of factors, whatever is the number of factors, you're sorting it. The internal sorting function takes n log in. What is the internal sorting function taking? N log in, what is N? N is the number of factors? N is the number of factors. Right? So can I say N is the number of factors? N is not the original N. It is the number of factors. and then you're going ahead and printing it. So you're again taking a number of factors time to print it. Whatever is the number of time? So the overall time complexity in this case is we go of square root of 1. Plus we go of number of factors into log of number of factors. So number of factors into log off, provided properly, number of factors. got it quite simple and then plus this so big of this plus big of this plus big of this is the time complexity but the motive was to teach you that you're gonna also find factors in be go of square root of n got it i can say i've also done print all divisors in both the ways now what is the next question it states check for prime so what is the definition of a prime number a lot of you will say a number that is divisible by one and itself this is a wrong definition why because according to this definition one is a prime number because one is divisible by one and one is divisible by itself which is one it's a wrong definition instead of this the definition that you should always keep in mind is a number that has exactly two factors one and itself that's a better definition one and itself a number that has two factors which is one and itself so if you remember we're just now computed factors so if you're given a number something like 11 can i say 11 has a factor of 1 and 11 itself any other number doesn't divide 11 so 11 is a prime number if i say 13 30 is a prime number because 1 and 13 divides it whereas a 5 5 is a prime number because 1 and 5 divides it If I say 4, 4 is not a prime number. Why? Because it is divisible by 1. It is divisible by 2. It is also divisible by 4. So there are three factors. So 4 is not a prime number. We take 8. It is not a prime number. Why? Divisible by 1, 2, 4, 8. So not a prime number. Something like 17 is a prime number because divisible by 1 and 17. So what is the first, the brute force? What is the definition of brute force? The algorithm which is the first algorithm or the initial algorithm that comes to your mind. Okay. So can I see the simplest way to check is I will do one thing. I'll keep a counter equal to zero. And I know it exactly has two factors. So I'll run a loop from one and I'll go on till N and I'll say I plus plus and I'll say hey listen. if it is a factor, it will be completely divisible by i, hence it will leave a remainder 0 and I'll do a counter plus plus. And can I say at the end of the day, if the counter turns out to be 2, then I'll say it's a prime number or else it's not a prime number. So can I say this is the extreme brute force approach? And if I write the extreme brute force approach, what will be the time? complexity of the extreme brute force approach. Can I say I'm running a loop n and these are unit operations so I can ignore? So can I say the time complexity will be bego of n because I'm running a l loop to check for every I, which can be a factor and then I'm checking it and there is and after that there are conditional checks which are unit operations can be avoided. So this is bgo of n and we know that factors are involved. In the previous problem, we did learn. that all the factors can be found in square root of n. Why? Because if you remember 36, 36 had a factor 1. The corresponding factor like the corresponding other factor was 36. 2's 18, 3 is 12, 4s, 9 and 66. Even if you checked till square root of n, you could actually count all the factors. And all the factors were 1, 2, 3, 4, 6, 9, 12, 8,000, 8,000. in 36, you can count all the factors. Even if you loop till square root of n. So why are you looping till we go of n? Kindly look till square root of n. So what do you'll do is you'll say I equal to 1. I into I lesser than n, I've already taught you this and count a equal to 0. And you'll say if N modulo I is equal to 0, that is definitely a factor. and at the same time, the other factor has to be different. And if the other factor is different, then it will also be counted. And then you can have a seam check. If counter is equal to equal to 2, prime, else not a prime number. As simple as that. And if I talk about the time complexity, this loop ends up running for Bgo of square root of n. So if someone is coming up and asking you, how do you check? for a prime number, you say I know the square root method. Because I know the observation. Every factor there is the other corresponding number with which it has to get multiplied in order to get the number. Thereby I can just go up to square root of n. Nothing beyond it. Because still square root of n, I'll get all the factors. So this is the code that I did write in the iPad. So I'll know quickly go ahead and submit this and see if it is working fine. It is indeed working fine. So we have completed the check for prime. So apparently you have completed everything and the GCD or the HCF is left. So let's go across and learn the GCD or HCF and then come back and take it over. So what do you mean by GCD or HCF? It's very simple. Greatest common divisor or highest common factor. Let me give you an example. If I give you two numbers, N1 equal to 9 and N2 equal to 12, so you need to find the highest common factor or greatest common divisor that actually divides. and that divides 9 and 12 so if I write down all the factors of 9 it is 1 3 and 9 if I write down all the factors of 12 it is 1 2 6 and 12 even 3 4 that these are all the factors of 12 so if I ask you the common factors the common factors if I go ahead and mark it is 1 1, it is 3, 3. So there are two common factors. Out of these two common factors, which is the highest one, 3. So I can say the GCD of 9.12 is 3 because 3 is the largest number that divides 9 and 12 both. If I ask you the GCD of 11 and 13, what will be it? It will be 1. Because if you try to write down all the factors of 11, it's going to be 1 and 11. All the factors of 13, 1 and 13. So the common one is just one and that is the GCD. So there will always be a GCD because one is a number that divides every other number. So for every given two numbers, there will always be a GCD or HCF. If I ask you, what is the GCD of 20, 30 or rather 20, 40? What is the GCD of 20?40? Because for 20, 20, 20 is a factor. And for 40, 20 is also a factor. So that's why 20. So for two given numbers, one of them can also be a GCD of those two given numbers. So that is what is the definition of GCD. So all of you know how to find factors of two given numbers. you give in n1 and you're given n2 so in the last two problems you have learned how to find factors so imagine it's like n1 is 9 and n2 is 12 so can i say if i loop from 1 to 12 and for every number i'll check if they're dividing both does 1 divide both yes one as of now is the largest factor Does 2 divide both? No. Does 3 divide both? Yes. So 3 is the largest. If I can check every number and if every number divides both of them, if a number divides both of them, I just replace that with my GCD's answer. And the largest number that I get, that divides both of them will be my GCD. If I try to write it, can I write this as I equal to 1? Maybe I will loop till N1? maybe i plus plus and i'll say if n1 modulo i equal to equal to zero and n2 modulo i equal to 0 and i'll say as of now i know one thing for sure any given two numbers any given two numbers will always have a gcd of 1 so gcd will be replaced by i can i see this because i is starting from 1. So it goes from 1, then it goes to 2, then goes to 3. So whichever number divides both of them, it just keeps on getting replaced. The last number, which will be stored in GCD, will definitely be the largest because I is moving in the increasing fashion. Very simple. Now, you might ask me, but Striver, what if N was given as 12 and N2 was given as 9? then the fall loop would have been running for 12 times. But I know one thing for sure that if IS 10, the 10 will not divide 9. There is no point in checking. So can I say instead of running till N1, I can actually run it for something like minimum of N1. Because I know if I run till minimum of N1 comma N2, like now, If I run till 9, that will suffice. Running 10, 11 doesn't make sense. For example, if the number was 20 and 40, if I run until 20, that will work. Because 20 is the largest factor I can have. Running it for 21, 22 will not make sense. So can I say I can run the loop till minimum of N1 comment? I can? Thereby, can I say the time complexity will be We go of minimum of N1 comma N2, whichever is minimum. Till that I'll run the loop. So thereby the time complexity is minimum of N1 comma N2. Now you might have questions in your head. But Striver, we are trying to find highest. And over here, what are you doing? You're going from 1, 2, 3, 4 and you're checking everyone. But what if N1 is 20, N2 is 40? and I do the other way. Yes, I do the other way and I say, I'll run it from minimum of N1 comma N2, I greater than equal to 1, I minus minus, and I'll say if N1 modulo I equal to 0 and N2 module I equal to equal to 0, I will print that as my GCD and I'll break and I'll break. and you know what is the task of break it always breaks out from the outer loop not this is a conditional statement this is not a loop for this break which is the loop that is outside this break this one it will break out from this how does it work the minimum of 20 40 is 20 so 20 20 modulo 20 equal to 0 yes 40 modular 20 equal to 0 yes print GCDS 20 yes break. So the program terminates. In this way you will say in this way it will have a better complexity because the moment you are getting someone from behind it breaks out. You might give me this. Yeah definitely this might turn out to be a better one for a lot of cases. But still the worst case will be minimum of n1 comma n2. Imagine I give you two numbers. N1 equal to 11. N2. N2 to 13. In this case, what will happen? For 11 and 13, the highest common factor is 1. It will start from 11, 10, 9, but will not find anyone till 1. So, it will eventually loop from 11 to 1. So no matter what you do, the time complexity will be still this. Because if both the numbers of GCD as 1, it ends up running completely. The loop ends up running completely. And you know when you determine the time complexity, taught you in the time complexity lecture, you always take worst case. You always take worst case. The worst case is when you run it till one. We saw the previous method was a brute force method and was taking linear time complexity. Now there is an algorithm known as equiloidian algorithm which is going to take much, much lesser time. So let's learn about it. So what is equiloidian algorithm? It states if you're given two numbers n1 comma n2, The GCD of N1 comma N2, whatever is the GCD of N1 comma N2, that's equivalent to the GCD of N1 minus N2 where where N1 is greater than N2. Usually in books you will find them written as GCD of A comma B is equal to GCD of A minus B comma B where A is greater than B. This is what the E. Ecculloidian algorithm states. If you want a mathematical proof of it, you can definitely Google search. There's a huge mathematical proof to it. Again, we will not go deep into the mathematical proof because it is not required in programming world. You just need this concept. So just have the concept. Now, if I try to prove this with induction, it's very simple. If I give you two numbers, imagine 15 and 20. So it basically states the greater number and the smaller number. What is the GCD of 20 comma 5? We know the GCD of 20.15 is 5. So it states the GCD of 20.15, the greater number 20 and the smaller number 15 is equal to, it states greater minus smaller. 20 minus 15. 5 comma the smaller number 15. So what is the GCD of 5? That is also 5. So again, by induction also you can prove it. You can take any two numbers and you'll be able to prove that they are same. So I can say that the GCD of 20.15 is equivalent to the GCD of 5.5. Now, you applied the Echoloidion on the first two numbers and whatever you get, that will always be a truncated number. You saw 20 getting truncated to 5. again you will apply equilodeon to this if we try to apply equilodeon to 5.15 it has to be the greater number at first so apparently you have to apply equilordion to 15.5 because 15 is the greater number right so what do you do is you say okay let's apply equalardion to 15 comma 5. They'll be like GCD of 15 minus 5 10.5 again you can apply equiloidian to 10.5. If you apply Echlorid into 10.5, it will be greater is 10, 10 minus 5 is 5. 5.5. Again, if you apply equiloid into 5.5, it will be both of them are same. Anyone can be at the front. 0.5. So 1 apparently becomes 0. The moment one of the numbers become 0. The other number is actually a GCD. It is actually a GCD. So the GCD of 20.15 is this. What do you do is you take two numbers, apply equal idea, get it smaller, apply equal idea, get it smaller, get it smaller, till one of them is zero. If one of them is zero, the other is zero. So the algorithm is quite simple. Start with A comma B, keep on truncating, keep on truncating with A minus B comma B and keep on doing till one of them, the greater number becomes zero. That's simple as well. But there's a catch. this might end up taking a lot more time. Imagine I give you a number like A equal to 52 and B equal to 10. So it'll be like, what will you do? You will say GCD of 52.10 truncated to GCD 402.10, truncated to GCD 32.10. Truncated to GCD 32.10. Truncated to GCD 22.2. Truncated to GCD 12.10. truncated to GCD 2.10 and then you again take the bigger number at first, 10.2, and then you'll be again like truncated to 8.2, truncated to 6.2, 4.2, 2.2 and 2.2 and ultimately, 2 is left because everything comes up. So, it's a lot of sticks. It's a lot of sticks. It might not improve the linear complexity by so much. But there's a catch over here. if it is 52 and it was 10 and you're reducing it with 10 every time and you ended up at a place of 2.10 isn't it equivalent to saying you're dividing it by 10 and you're like 52 if you divide it by 10 it's like 5 you did it 5 times 1 2 3 4 5 and you ended up having the remainder because you are minus 10 minus 10 minus 10 till it is possible It's equivalent to saying you subtract it till it was possible or till it is greater. Can I see instead of subtracting it five times, you could have directly gone from here to here by saying 52 Modulo 10.10. That's same. 2.10. That is same instead of subtracting 10, 5 times, directly get 2.2. even from 10 comma 2 to 0.2, you could have directly gone by saying 10 modulo 2 because that is what you did indirectly simple match. So can I see the algorithm in a better sense will be GCD of A comma B, but definitely A is greater than B is equal to A modulo B. That's a better one. And you go on doing it. Then it becomes zero as simple as that. You always take the greater number. So the logic is very simple. Forget about A and B. The logic is very simple. The greater, modular is smaller. That's the logic. And they go on till one of them is zero. And if one of them is zero, remember this. If one of them is zero, the other is GCD. The other is GCD. As simple as this. If I try to code this up, try to quote this up. you're given A, a given B, can I say you go on till both of them are greater, greater than zero? Very simple. And I know one of them will be greater. Either A will be greater. In that case, I'll do A module B. Or else if B is greater, I'll do B module A instead of swapping changing because I did not want to get into swapping changing. Why? Over here it was 2.10. So A was this, B was there. And you swapped it to this. I did not want to improve. implement that I just I knew now 10 will be modulated so what I did was I implemented it in such a way stating if a is greater a will be modulated if b is greater we will be modulated and once this is over if a is zero if a becomes zero and the wild loop is false can I say the GCD will be b I will or else can I say the GCD will be print of a simple simple as simple Yes. You can just take this example 52.10 and you can do a dry run on this. And you will see that eventually one of them will become zero and that is when the looping ends. And the time complexity of this equilardine algorithm is we go of log of phi, minimum of A comma B. Why log? If you remember, I clearly stated during the digit extract. or in the pattern videos or the time complexity videos that whenever there is division happening whenever there is division happening the number of iterations will be in terms of logarithm over here there is modulo you are reducing the number by division the modulation operations are happening thereby the time complexity will be in terms of logarithm now why if i why not something like log based in the digit extraction it is always is n by 10 over here this a and v it's always changing fluctuated you're not sure what will be a and v depending on different examples it will fluctuate that is why they're given them given it a term phi if you want to know what is phi in depth there's a huge mathematical proof to it not required you can read it but it's not required and minimum of a comma b because that is the initial number where you start from as the initial number we start to do it So that's why the time complexity is this. No one is going to ask you how and everything. Just keep it in mind that the time complexity is log 5 minimum of A comma B. This is the equality now. So written the same code after if I've not given else because if this line doesn't, if this line executes the function would have end and this line will not execute. That's why. So now I'll go ahead and run this code and it is running absolutely fine. and if I'll submit this, we get the correct answer. So with this, we'll be wrapping up the basic maths. Next is basic recursion. I've already made videos on it. I'll be attaching them to the playlist. So watch this match video. Post that go and watch the basic recursion video. Once you have done this, then we will be going across to the next topic. That is basic hashing and I'll be explaining hashing in depth. But I hope for this video, you've understood basic maths completely just in case you have please hit that like button and to follow a ritual do comment understood so that i get an idea that you guys are understanding and you watch the video till here if you're new to our channel what are you please please do consider subscribing to us because that is the only thing that keeps me motivated to make these kind of content and here with this i'll be wrapping up this video let's be in some of the video till then goodbye to you know whenever your heart is broken don't ever forget your I didn't.",
    "chunks": [
        {
            "timestamp": [
                0.0,
                4.62
            ],
            "text": " Hey everyone, welcome back to the channel."
        },
        {
            "timestamp": [
                4.72,
                6.22
            ],
            "text": " I hope you guys are doing extremely well."
        },
        {
            "timestamp": [
                6.58,
                10.2
            ],
            "text": " So this video is going to be another video from the strivers A2Z DSA course."
        },
        {
            "timestamp": [
                10.66,
                14.54
            ],
            "text": " And this is India's most in-depth DSALGO course."
        },
        {
            "timestamp": [
                14.6,
                15.28
            ],
            "text": " Why do I see that?"
        },
        {
            "timestamp": [
                15.34,
                18.2
            ],
            "text": " Because this course has 455 modules."
        },
        {
            "timestamp": [
                18.66,
                23.12
            ],
            "text": " I can guarantee you that you can take any paid batches, any free courses."
        },
        {
            "timestamp": [
                23.54,
                26.16
            ],
            "text": " None of those courses will have 455 modules."
        },
        {
            "timestamp": [
                26.16,
                29.98
            ],
            "text": " This is an extremely in-depth DSALGO course that can teach you."
        },
        {
            "timestamp": [
                0.0,
                3.16
            ],
            "text": " everything in breadth about DS Algo."
        },
        {
            "timestamp": [
                3.52,
                7.84
            ],
            "text": " And in the previous videos, we have covered step 1.1 and 1.2."
        },
        {
            "timestamp": [
                8.38,
                13.06
            ],
            "text": " And regarding step 1.3, I've added a video on C++ STL on the playlist."
        },
        {
            "timestamp": [
                13.52,
                14.52
            ],
            "text": " You can go and watch it."
        },
        {
            "timestamp": [
                14.84,
                18.58
            ],
            "text": " Regarding Java collection, I'll be adding a video in the future, not now."
        },
        {
            "timestamp": [
                18.88,
                22.34
            ],
            "text": " If you need a video now, you can go to YouTube and you'll find a lot of other resources"
        },
        {
            "timestamp": [
                22.34,
                23.92
            ],
            "text": " from where you can study."
        },
        {
            "timestamp": [
                24.56,
                27.94
            ],
            "text": " So in this video, we will be discussing about basic maths."
        },
        {
            "timestamp": [
                0.0,
                2.94
            ],
            "text": " Why am I teaching just the basic maths as of now?"
        },
        {
            "timestamp": [
                3.24,
                4.44
            ],
            "text": " So you're starting off as of now."
        },
        {
            "timestamp": [
                4.78,
                6.46
            ],
            "text": " Your brain will not be that matured."
        },
        {
            "timestamp": [
                6.5,
                8.64
            ],
            "text": " So if I teach you the advanced level concepts,"
        },
        {
            "timestamp": [
                8.94,
                12.96
            ],
            "text": " you might understand, but it won't be that convenient for you."
        },
        {
            "timestamp": [
                13.02,
                15.2
            ],
            "text": " That is why my teaching way is very different."
        },
        {
            "timestamp": [
                15.32,
                18.0
            ],
            "text": " What I do is I usually start off with the basic stuffs."
        },
        {
            "timestamp": [
                18.36,
                20.1
            ],
            "text": " I give you a lot of time to absorb it."
        },
        {
            "timestamp": [
                20.28,
                21.72
            ],
            "text": " And then we move on to the advanced part."
        },
        {
            "timestamp": [
                21.96,
                24.78
            ],
            "text": " This is why all the basic stuffs are initially there."
        },
        {
            "timestamp": [
                25.02,
                26.62
            ],
            "text": " And then we move on to the DSALGO."
        },
        {
            "timestamp": [
                27.02,
                29.82
            ],
            "text": " And in the step 8, we have a section as advanced mathematics."
        },
        {
            "timestamp": [
                0.0,
                4.8
            ],
            "text": " we'll be covering everything that is related to advanced mathematics that might be asked in interviews."
        },
        {
            "timestamp": [
                5.2,
                7.44
            ],
            "text": " But as of now, we will be learning basic maths."
        },
        {
            "timestamp": [
                7.74,
                9.66
            ],
            "text": " Now, these are the problems which we will be solving."
        },
        {
            "timestamp": [
                10.08,
                14.26
            ],
            "text": " But before that, let's learn some basic maths concept."
        },
        {
            "timestamp": [
                14.74,
                18.18
            ],
            "text": " So before solving all the problems that are listed under basic maths,"
        },
        {
            "timestamp": [
                18.58,
                21.62
            ],
            "text": " we'll be starting off with the basic maths concept."
        },
        {
            "timestamp": [
                21.98,
                27.26
            ],
            "text": " I'll be teaching you the concepts initially and then we can solve all the problems listed under the section."
        },
        {
            "timestamp": [
                0.0,
                3.52
            ],
            "text": " The first concept that I'll be teaching you is the digit concept."
        },
        {
            "timestamp": [
                4.1,
                4.94
            ],
            "text": " Remember one thing."
        },
        {
            "timestamp": [
                5.32,
                7.12
            ],
            "text": " This is a very, very important concept."
        },
        {
            "timestamp": [
                7.64,
                15.42
            ],
            "text": " Because if you know how to play around digits, then you'll be able to solve most of the problems in basic maths."
        },
        {
            "timestamp": [
                15.86,
                17.52
            ],
            "text": " Let's understand the digit concept."
        },
        {
            "timestamp": [
                18.02,
                21.96
            ],
            "text": " Imagine I give you a number like 7-7-8-9."
        },
        {
            "timestamp": [
                22.38,
                24.18
            ],
            "text": " This is the number that I'm giving you."
        },
        {
            "timestamp": [
                24.46,
                28.28
            ],
            "text": " Now, I ask you to perform extraction of digits."
        },
        {
            "timestamp": [
                0.0,
                3.24
            ],
            "text": " I ask you to perform extraction of digits."
        },
        {
            "timestamp": [
                3.76,
                5.98
            ],
            "text": " Let's learn the extraction of digits."
        },
        {
            "timestamp": [
                6.46,
                11.72
            ],
            "text": " And after that, you will see how we can implement the extraction of digits in order to solve most of the problems."
        },
        {
            "timestamp": [
                12.08,
                15.02
            ],
            "text": " So when I say extraction of digits, what does it mean?"
        },
        {
            "timestamp": [
                15.18,
                20.96
            ],
            "text": " It means, I need nine, I need eight, I need seven, I need seven."
        },
        {
            "timestamp": [
                21.36,
                23.66
            ],
            "text": " I need all the digits individual."
        },
        {
            "timestamp": [
                24.28,
                26.02
            ],
            "text": " So what is this digit?"
        },
        {
            "timestamp": [
                26.38,
                26.6
            ],
            "text": " Nine."
        },
        {
            "timestamp": [
                27.28,
                28.5
            ],
            "text": " Can I see this?"
        },
        {
            "timestamp": [
                0.0,
                3.3
            ],
            "text": " If I do a module 10, I'll actually get 9."
        },
        {
            "timestamp": [
                3.72,
                4.98
            ],
            "text": " You might ask why."
        },
        {
            "timestamp": [
                6.02,
                9.74
            ],
            "text": " If I ask you, the numbers that are divisible by 10, what are they?"
        },
        {
            "timestamp": [
                10.32,
                17.0
            ],
            "text": " 10, 20, 30, 40, 50, 60, 70, so on, 100 and so on."
        },
        {
            "timestamp": [
                17.62,
                18.36
            ],
            "text": " Do you see a pattern?"
        },
        {
            "timestamp": [
                19.08,
                23.88
            ],
            "text": " All the numbers that are divisible by 10 are actually ending with 0, is it?"
        },
        {
            "timestamp": [
                24.38,
                24.7
            ],
            "text": " Right?"
        },
        {
            "timestamp": [
                25.3,
                29.88
            ],
            "text": " So, can I say, if I'm doing a module 10, what is the meaning of modular operator?"
        },
        {
            "timestamp": [
                0.0,
                1.0
            ],
            "text": " in basic max."
        },
        {
            "timestamp": [
                1.0,
                6.54
            ],
            "text": " The module operator says, I will divide the number by 10 and whatever is the remainder,"
        },
        {
            "timestamp": [
                6.54,
                7.98
            ],
            "text": " that is what I'll give you."
        },
        {
            "timestamp": [
                7.98,
                12.88
            ],
            "text": " So if I say, if I'm dividing this number by 10, what is the nearest number?"
        },
        {
            "timestamp": [
                12.88,
                17.48
            ],
            "text": " Obviously that will be 7, 7, 8, 0."
        },
        {
            "timestamp": [
                17.48,
                21.12
            ],
            "text": " If I divide it by 10, this is what the nearest number will be."
        },
        {
            "timestamp": [
                21.12,
                24.48
            ],
            "text": " And can I say that the remainder then will be 9?"
        },
        {
            "timestamp": [
                24.48,
                29.16
            ],
            "text": " Because if I divided by 10, then this is where the division, like this is the number which"
        },
        {
            "timestamp": [
                0.0,
                2.0
            ],
            "text": " which will get divided by 10."
        },
        {
            "timestamp": [
                2.0,
                5.5
            ],
            "text": " And after that we'll be left out with 9."
        },
        {
            "timestamp": [
                5.5,
                8.0
            ],
            "text": " That is why when you do a module 10,"
        },
        {
            "timestamp": [
                8.0,
                11.0
            ],
            "text": " you always get the last digit."
        },
        {
            "timestamp": [
                11.0,
                13.5
            ],
            "text": " You get the last digit as 9."
        },
        {
            "timestamp": [
                13.5,
                15.0
            ],
            "text": " So this is how you get the 9 digit."
        },
        {
            "timestamp": [
                15.0,
                18.5
            ],
            "text": " If I ask you, can I get the next digit 8?"
        },
        {
            "timestamp": [
                18.5,
                20.5
            ],
            "text": " How will you get the next digit 8?"
        },
        {
            "timestamp": [
                20.5,
                21.5
            ],
            "text": " Very simple."
        },
        {
            "timestamp": [
                21.5,
                25.0
            ],
            "text": " You say, okay, this number, let's divide it by 10."
        },
        {
            "timestamp": [
                25.0,
                28.0
            ],
            "text": " So if I divide 7, 7, 7, 8, 9 by 10,"
        },
        {
            "timestamp": [
                28.0,
                29.9
            ],
            "text": " can I say I'll get 7, 7,"
        },
        {
            "timestamp": [
                0.0,
                3.06
            ],
            "text": " 778.9. Can I say this?"
        },
        {
            "timestamp": [
                3.56,
                8.48
            ],
            "text": " If I divide the number 7789 by 10, I'll get 778.9."
        },
        {
            "timestamp": [
                8.96,
                15.3
            ],
            "text": " And if I take an integer round of, if I take an integer portion of it, the integer portion is 7.78."
        },
        {
            "timestamp": [
                15.8,
                20.98
            ],
            "text": " So what you will do is, in order to go to the next step, you will say divide by 10."
        },
        {
            "timestamp": [
                21.42,
                27.86
            ],
            "text": " If you do your division by 10, you'll actually get 778.9, but you just take the integer part."
        },
        {
            "timestamp": [
                0.0,
                2.28
            ],
            "text": " That is why you get 778."
        },
        {
            "timestamp": [
                2.94,
                8.46
            ],
            "text": " So once you have 778 with you, if I need the last digit, which is 8, how do you extract it?"
        },
        {
            "timestamp": [
                8.8,
                9.84
            ],
            "text": " Again, the same way."
        },
        {
            "timestamp": [
                10.36,
                13.26
            ],
            "text": " You see, can I divide modularize with 10?"
        },
        {
            "timestamp": [
                13.82,
                16.74
            ],
            "text": " If I do a mod of 10, I'll actually get 8."
        },
        {
            "timestamp": [
                16.8,
                17.0
            ],
            "text": " Why?"
        },
        {
            "timestamp": [
                17.42,
                23.46
            ],
            "text": " Because the nearest number will be 770, which is divisible by 10, which will still leave a remainder of 8."
        },
        {
            "timestamp": [
                23.8,
                26.18
            ],
            "text": " So I get the digit 8 as well."
        },
        {
            "timestamp": [
                26.5,
                29.14
            ],
            "text": " Now, can I see if I require the next digit 7?"
        },
        {
            "timestamp": [
                0.0,
                3.02
            ],
            "text": " can I again do a division by 10?"
        },
        {
            "timestamp": [
                3.58,
                7.64
            ],
            "text": " If I do a division by 10, can I say I'll get 77?"
        },
        {
            "timestamp": [
                8.12,
                8.38
            ],
            "text": " Why?"
        },
        {
            "timestamp": [
                8.5,
                16.9
            ],
            "text": " Because if I write 778 by 10, I'll get 77.8 and the integer portion is 77."
        },
        {
            "timestamp": [
                17.3,
                18.12
            ],
            "text": " So I get 77."
        },
        {
            "timestamp": [
                18.64,
                25.16
            ],
            "text": " Again, if I have to extract the last digit, can I say I'll do a modular rise, a modulo of 10, and I'll get 7."
        },
        {
            "timestamp": [
                25.62,
                26.02
            ],
            "text": " I will."
        },
        {
            "timestamp": [
                26.82,
                29.24
            ],
            "text": " Hence, I have again extracted 7."
        },
        {
            "timestamp": [
                0.0,
                14.94
            ],
            "text": " Now, if I need the next extraction, I again divided by 7, so I divided by 10, and I'll get 7 because 77 divided by 10 is 7.7 and the integer part is 7."
        },
        {
            "timestamp": [
                15.02,
                15.6
            ],
            "text": " So I get 7."
        },
        {
            "timestamp": [
                15.96,
                20.62
            ],
            "text": " If I do a modularize of 10, I'll actually again get 7."
        },
        {
            "timestamp": [
                21.0,
                22.12
            ],
            "text": " Why will you get again 7?"
        },
        {
            "timestamp": [
                22.66,
                28.28
            ],
            "text": " Very obvious because the nearest number that is divisible by 10 to 7 is 0."
        },
        {
            "timestamp": [
                0.0,
                29.98
            ],
            "text": " thereby you get a remainder of 7 so you get 7 after that if you again try to divide it by 10 this time you'll end up getting 0 because if I take 7 divided by 10 it will be 0.7 as the integer part is 0 so can I see if I get an integer part is 0 can I say I've extracted all the digits I have and if you see the extraction has been done in the reverse order and all the digits have been extracted as simple as"
        },
        {
            "timestamp": [
                0.0,
                5.6
            ],
            "text": " that so this is how you can easily extract all the digits so if i try to write the pseudo code how"
        },
        {
            "timestamp": [
                5.6,
                12.08
            ],
            "text": " will the pseudo code look like can i say if i have the n i can take take it from the user i can"
        },
        {
            "timestamp": [
                12.08,
                17.2
            ],
            "text": " take the end from the user and imagine i'm asking you to print all the digits extract all the"
        },
        {
            "timestamp": [
                17.2,
                22.8
            ],
            "text": " digits like nine eight seven seven and you can print it so how will you do it it's very simple"
        },
        {
            "timestamp": [
                23.44,
                29.92
            ],
            "text": " i will be like okay while i know what is the last step last step is the extraction goes on from n"
        },
        {
            "timestamp": [
                0.0,
                3.62
            ],
            "text": " when it is 7-789 to n till 0."
        },
        {
            "timestamp": [
                4.12,
                7.08
            ],
            "text": " So I'll be like, I'll go on till n is greater than 0,"
        },
        {
            "timestamp": [
                7.16,
                10.06
            ],
            "text": " which means till n doesn't becomes 0, right?"
        },
        {
            "timestamp": [
                10.4,
                12.66
            ],
            "text": " And can I see the extraction is very simple."
        },
        {
            "timestamp": [
                13.08,
                16.24
            ],
            "text": " The first time, N was 7-789."
        },
        {
            "timestamp": [
                16.56,
                18.88
            ],
            "text": " If I had to do an extraction, it's very simple."
        },
        {
            "timestamp": [
                19.38,
                24.4
            ],
            "text": " Can I say the last digit is nothing but N modularized 10?"
        },
        {
            "timestamp": [
                25.0,
                28.22
            ],
            "text": " If I do an N modularized 10, I'll get the last digit 9."
        },
        {
            "timestamp": [
                0.0,
                2.46
            ],
            "text": " and in order to get the next digit,"
        },
        {
            "timestamp": [
                3.14,
                4.1
            ],
            "text": " what I do is I say"
        },
        {
            "timestamp": [
                4.1,
                6.36
            ],
            "text": " N is N by 10"
        },
        {
            "timestamp": [
                6.36,
                8.1
            ],
            "text": " and this is how I can do it."
        },
        {
            "timestamp": [
                8.44,
                9.12
            ],
            "text": " So what will happen?"
        },
        {
            "timestamp": [
                9.36,
                10.34
            ],
            "text": " Let's do a dry rod."
        },
        {
            "timestamp": [
                10.92,
                12.42
            ],
            "text": " At first, imagine I give"
        },
        {
            "timestamp": [
                12.42,
                15.5
            ],
            "text": " the user gives N as 7,789."
        },
        {
            "timestamp": [
                16.06,
                19.2
            ],
            "text": " So this says 7789 greater than 0,"
        },
        {
            "timestamp": [
                19.32,
                19.9
            ],
            "text": " which is true."
        },
        {
            "timestamp": [
                20.36,
                24.04
            ],
            "text": " So the last digit happens to be 7789"
        },
        {
            "timestamp": [
                24.04,
                27.2
            ],
            "text": " modularized 10 and the last digit is 9."
        },
        {
            "timestamp": [
                27.6,
                29.16
            ],
            "text": " If you want to print this last digit,"
        },
        {
            "timestamp": [
                0.0,
                6.28
            ],
            "text": " you can definitely put a print operation in c plus plus it is c out in java it is system dot out"
        },
        {
            "timestamp": [
                6.28,
                11.18
            ],
            "text": " printl so you can go ahead and print the nine once you've done this can i say if you do"
        },
        {
            "timestamp": [
                11.18,
                18.6
            ],
            "text": " 7 7 7 8 9 by 10 then the end will reduce itself what will be the value of n now can i say the"
        },
        {
            "timestamp": [
                18.6,
                26.02
            ],
            "text": " value of n will be nothing but 7 7 7 8 this is how the first iteration first iteration will"
        },
        {
            "timestamp": [
                26.02,
                29.98
            ],
            "text": " happen and then it will reach here then again goes here now when it goes"
        },
        {
            "timestamp": [
                0.0,
                6.12
            ],
            "text": " here it will be a new iteration and can I say this time the iteration will be 778 because"
        },
        {
            "timestamp": [
                6.12,
                12.46
            ],
            "text": " n has changed itself to 778 and 778 greater than 0 what will do is I'll quickly"
        },
        {
            "timestamp": [
                12.46,
                18.04
            ],
            "text": " erase this because it's the next iteration so let's quickly raise this and the next"
        },
        {
            "timestamp": [
                18.04,
                24.26
            ],
            "text": " iteration what will happen it will see 778 modularize 10 the last digit this time will"
        },
        {
            "timestamp": [
                24.26,
                29.98
            ],
            "text": " be 8 again you can print that last digit and this time it will be 778 by 10 hence"
        },
        {
            "timestamp": [
                0.0,
                6.56
            ],
            "text": " Since n will become 77, again the iteration will go and will be 77 greater than 0."
        },
        {
            "timestamp": [
                6.98,
                12.0
            ],
            "text": " And this way, all these steps will be performed at the end of the day, the value of"
        },
        {
            "timestamp": [
                12.0,
                14.26
            ],
            "text": " N, yes, the value of the N will be 0."
        },
        {
            "timestamp": [
                14.78,
                16.94
            ],
            "text": " Hence the while loop will be false."
        },
        {
            "timestamp": [
                17.34,
                22.18
            ],
            "text": " And I can say that the execution has been completed and you have successfully extracted"
        },
        {
            "timestamp": [
                22.18,
                24.86
            ],
            "text": " all the digits in the reverse fashion."
        },
        {
            "timestamp": [
                25.26,
                27.04
            ],
            "text": " Very important in the reverse fashion."
        },
        {
            "timestamp": [
                27.38,
                27.7
            ],
            "text": " Got it?"
        },
        {
            "timestamp": [
                27.92,
                29.98
            ],
            "text": " So this is what is the concept of."
        },
        {
            "timestamp": [
                0.0,
                4.34
            ],
            "text": " extraction of digits and this is going to help you solve a lot of other problems as well."
        },
        {
            "timestamp": [
                5.08,
                10.74
            ],
            "text": " So now let's look at the first problem. It states count digits. Let's understand the problem."
        },
        {
            "timestamp": [
                11.36,
                16.76
            ],
            "text": " Given the number n, find out and return the digits present in a number. Very simple."
        },
        {
            "timestamp": [
                17.42,
                23.74
            ],
            "text": " It says 156 is the number and the number of digits is three. Imagine the N is given as 7."
        },
        {
            "timestamp": [
                23.74,
                29.98
            ],
            "text": " It has just one digit. So it'll be given an N and you'll tell me the number of digits. So if I go"
        },
        {
            "timestamp": [
                0.0,
                6.92
            ],
            "text": " back to my iPad, can I say, if I give you the number 7,7, 8, 9, this has 4 digits."
        },
        {
            "timestamp": [
                7.64,
                13.24
            ],
            "text": " Can you solve this problem using the extraction of digits? Can you? You'll be like, this is super easy."
        },
        {
            "timestamp": [
                13.9,
                20.38
            ],
            "text": " Why? Because you know the extraction of digits. You know one digit, 2 digit, 3 digit, 4 digit."
        },
        {
            "timestamp": [
                20.98,
                26.98
            ],
            "text": " The digits are extracted 4 times. So can I say, I can keep something like a counter variable over here?"
        },
        {
            "timestamp": [
                0.0,
                4.0
            ],
            "text": " and you know the number of times the extraction happens"
        },
        {
            "timestamp": [
                4.0,
                7.14
            ],
            "text": " that is the number of times the digit will be"
        },
        {
            "timestamp": [
                7.14,
                11.3
            ],
            "text": " so can I say I can put a counter equal to counter"
        },
        {
            "timestamp": [
                11.3,
                14.74
            ],
            "text": " plus one on the logic of extraction of digits"
        },
        {
            "timestamp": [
                14.74,
                19.58
            ],
            "text": " if I do this can I say I'll be able to count the number of digits"
        },
        {
            "timestamp": [
                19.58,
                22.48
            ],
            "text": " and eventually if I print the count over here"
        },
        {
            "timestamp": [
                22.48,
                26.86
            ],
            "text": " can I say that I'll always have the count of digits"
        },
        {
            "timestamp": [
                26.86,
                28.54
            ],
            "text": " of any given and I can"
        },
        {
            "timestamp": [
                0.0,
                4.36
            ],
            "text": " Usually in coding rounds or in your interviews, you just have to code the function."
        },
        {
            "timestamp": [
                4.78,
                10.72
            ],
            "text": " The function is an int function that means you have to return the count of digits and they'll be giving the input."
        },
        {
            "timestamp": [
                11.14,
                12.6
            ],
            "text": " So you're given the variable."
        },
        {
            "timestamp": [
                12.7,
                13.66
            ],
            "text": " You just have to return."
        },
        {
            "timestamp": [
                14.14,
                15.78
            ],
            "text": " You have to just write the code inside the function."
        },
        {
            "timestamp": [
                16.18,
                18.42
            ],
            "text": " Int main and everything will be written on the backend."
        },
        {
            "timestamp": [
                18.7,
                21.18
            ],
            "text": " I've already discussed about this in the pattern video."
        },
        {
            "timestamp": [
                21.28,
                23.84
            ],
            "text": " In case you haven't watched it, please go back and watch it."
        },
        {
            "timestamp": [
                24.18,
                26.82
            ],
            "text": " So this was the code that we discussed on the iPad."
        },
        {
            "timestamp": [
                0.0,
                6.84
            ],
            "text": " right so the count stores the count of digits so just return the count and then I'll"
        },
        {
            "timestamp": [
                6.84,
                11.16
            ],
            "text": " go ahead and run the code and I'll see that it is running absolutely fine and"
        },
        {
            "timestamp": [
                11.16,
                15.6
            ],
            "text": " then I'll go ahead and submit this so this is how you can easily solve this particular"
        },
        {
            "timestamp": [
                15.6,
                20.88
            ],
            "text": " now remember one thing this last digit does not have any significance so you"
        },
        {
            "timestamp": [
                20.88,
                25.2
            ],
            "text": " can remove it so that was for extraction of digits but this is kind of"
        },
        {
            "timestamp": [
                25.2,
                29.98
            ],
            "text": " reducing the numbers so the number of times it is divisible by 10 is the number of"
        },
        {
            "timestamp": [
                0.0,
                2.0
            ],
            "text": " of times the digits are."
        },
        {
            "timestamp": [
                4.0,
                6.68
            ],
            "text": " Now since I've removed the modular operation, we observe something."
        },
        {
            "timestamp": [
                7.24,
                11.4
            ],
            "text": " Can I say the number of times it is getting divisible by 10,"
        },
        {
            "timestamp": [
                11.52,
                15.3
            ],
            "text": " the number of times it is getting divisible by 10 is the count of the digits."
        },
        {
            "timestamp": [
                15.5,
                23.1
            ],
            "text": " It is and this is where something like logarithmic, log base 10, 7,789."
        },
        {
            "timestamp": [
                23.1,
                27.9
            ],
            "text": " If you do this in your calculator, it'll actually get something like 3.89 something."
        },
        {
            "timestamp": [
                28.62,
                29.98
            ],
            "text": " So this is the value that you'll get."
        },
        {
            "timestamp": [
                0.0,
                7.28
            ],
            "text": " if you do a log base 10 of the number and then if you can add a 1 to it this will be 4.89"
        },
        {
            "timestamp": [
                7.28,
                14.08
            ],
            "text": " and if you take an integer of it that will be 4 this is another way to find count of digits"
        },
        {
            "timestamp": [
                14.08,
                24.0
            ],
            "text": " what you do is very simple you say count is equal to log 10 the number plus 1 and you're saying"
        },
        {
            "timestamp": [
                24.0,
                29.98
            ],
            "text": " take the integer or you can just auto cast it like type cast it to integer this is"
        },
        {
            "timestamp": [
                0.0,
                3.6
            ],
            "text": " This is how whatever you get, this is converted to an integer."
        },
        {
            "timestamp": [
                3.6,
                7.24
            ],
            "text": " If we're getting 4.8 time, it'll be truncated to 4."
        },
        {
            "timestamp": [
                7.24,
                11.0
            ],
            "text": " And now let's run this and see if it is running fine."
        },
        {
            "timestamp": [
                11.0,
                13.24
            ],
            "text": " Okay, so it says out of scope."
        },
        {
            "timestamp": [
                13.24,
                15.76
            ],
            "text": " Lock 10 was not declared."
        },
        {
            "timestamp": [
                15.76,
                20.2
            ],
            "text": " So if you find such errors, what you can do is you can go to hash include."
        },
        {
            "timestamp": [
                20.2,
                25.4
            ],
            "text": " That's basically because in their backend, they might not have added all the directories."
        },
        {
            "timestamp": [
                25.4,
                29.7
            ],
            "text": " You can go ahead and add all the directories and that will start working fine."
        },
        {
            "timestamp": [
                0.0,
                2.44
            ],
            "text": " Once you've done this, you can go and compile and you're seeing that."
        },
        {
            "timestamp": [
                2.94,
                4.86
            ],
            "text": " You're seeing this, that this is also running."
        },
        {
            "timestamp": [
                5.0,
                7.78
            ],
            "text": " This is one of the other ways to count digits as well."
        },
        {
            "timestamp": [
                8.28,
                12.64
            ],
            "text": " But the primary concept is extraction of digits, and that is what you should focus on."
        },
        {
            "timestamp": [
                12.94,
                17.58
            ],
            "text": " Now, if I discuss the time complexity over here, what will be the time complexity?"
        },
        {
            "timestamp": [
                18.26,
                22.12
            ],
            "text": " The time complexity will be nothing but log base 10."
        },
        {
            "timestamp": [
                22.12,
                26.46
            ],
            "text": " And this is the bigot of time complexity."
        },
        {
            "timestamp": [
                27.46,
                29.22
            ],
            "text": " Why log base 10N?"
        },
        {
            "timestamp": [
                0.0,
                1.74
            ],
            "text": " The reason was very simple."
        },
        {
            "timestamp": [
                2.18,
                4.2
            ],
            "text": " You saw this is getting divisible by 10."
        },
        {
            "timestamp": [
                4.72,
                6.22
            ],
            "text": " How many times is the loop running?"
        },
        {
            "timestamp": [
                6.58,
                9.12
            ],
            "text": " The number of times it is getting divisible by 10."
        },
        {
            "timestamp": [
                9.68,
                14.84
            ],
            "text": " This is why you will say time complexity is near about log base 10."
        },
        {
            "timestamp": [
                15.38,
                18.04
            ],
            "text": " This was 3.89 near about 4."
        },
        {
            "timestamp": [
                18.6,
                21.44
            ],
            "text": " The number of times this loop did run was 4."
        },
        {
            "timestamp": [
                21.68,
                23.7
            ],
            "text": " Yeah, you can avoid these operations."
        },
        {
            "timestamp": [
                23.86,
                28.54
            ],
            "text": " These are single operations because imagine the number being very large."
        },
        {
            "timestamp": [
                0.0,
                3.02
            ],
            "text": " these will be considered as unit operations."
        },
        {
            "timestamp": [
                3.48,
                7.42
            ],
            "text": " That is why the time complexity is log base 10, n."
        },
        {
            "timestamp": [
                7.78,
                10.16
            ],
            "text": " Whenever there is division, remember this."
        },
        {
            "timestamp": [
                10.54,
                15.52
            ],
            "text": " Whenever there is division, if the division is happening by 10, you say log base 10."
        },
        {
            "timestamp": [
                15.62,
                19.64
            ],
            "text": " If the division is happening by 2, you say log base 2."
        },
        {
            "timestamp": [
                19.64,
                23.96
            ],
            "text": " And if the division is happening by 5, you say log base 5."
        },
        {
            "timestamp": [
                24.12,
                29.98
            ],
            "text": " This is how you compute the time complexity of like, this is how the logarithmic"
        },
        {
            "timestamp": [
                0.0,
                5.5
            ],
            "text": " time complexities are. So whenever you're writing a logic where the number of iterations depends"
        },
        {
            "timestamp": [
                5.5,
                14.36
            ],
            "text": " on division and you're dividing, dividing, that is when something like logarithmic will come"
        },
        {
            "timestamp": [
                14.36,
                19.78
            ],
            "text": " into the time complexity. That time the time complexity will not be ego of n. If the number"
        },
        {
            "timestamp": [
                19.78,
                25.76
            ],
            "text": " of iterations is based on division, time complexity will be logarithmic. Remember this always."
        },
        {
            "timestamp": [
                26.5,
                29.98
            ],
            "text": " So you solve the first problem count digits. The next problem is reverse a number."
        },
        {
            "timestamp": [
                0.0,
                1.0
            ],
            "text": " Let's go to the problem."
        },
        {
            "timestamp": [
                1.0,
                5.0
            ],
            "text": " It states write a program to generate the reverse of a given number."
        },
        {
            "timestamp": [
                5.0,
                7.0
            ],
            "text": " Print the corresponding reverse number."
        },
        {
            "timestamp": [
                7.0,
                11.0
            ],
            "text": " If a number has trailing zeros, then its reverse will not include them."
        },
        {
            "timestamp": [
                11.0,
                17.0
            ],
            "text": " For an example, the reverse of 104 will be 401 instead of 0401."
        },
        {
            "timestamp": [
                17.0,
                20.0
            ],
            "text": " And these are some of the examples."
        },
        {
            "timestamp": [
                20.0,
                24.0
            ],
            "text": " So let's get back to our extraction of digits concept."
        },
        {
            "timestamp": [
                24.0,
                29.0
            ],
            "text": " So according to the problem, what they are wanting is if I'm giving you the number 770,"
        },
        {
            "timestamp": [
                0.0,
                5.38
            ],
            "text": " 7-7-89, the reverse of this number will be 9-877."
        },
        {
            "timestamp": [
                6.06,
                11.74
            ],
            "text": " Now, we know that the extraction of digits happens in the reverse fashion, where we generate"
        },
        {
            "timestamp": [
                11.74,
                16.3
            ],
            "text": " 9, then we generate 8, then we get 7, then we get 7."
        },
        {
            "timestamp": [
                16.94,
                21.12
            ],
            "text": " Somehow, we need 9-877, which is the similar fashion."
        },
        {
            "timestamp": [
                21.72,
                24.62
            ],
            "text": " This is where the basic maths comes in."
        },
        {
            "timestamp": [
                0.0,
                8.0
            ],
            "text": " What do you do is you define a variable sum or maybe reverse number."
        },
        {
            "timestamp": [
                8.84,
                10.9
            ],
            "text": " Reverse number equal to zero."
        },
        {
            "timestamp": [
                10.9,
                22.2
            ],
            "text": " And you say reverse number equal to reverse number into 10 plus last digit."
        },
        {
            "timestamp": [
                22.42,
                22.94
            ],
            "text": " Remember this."
        },
        {
            "timestamp": [
                23.32,
                24.14
            ],
            "text": " This is what you say."
        },
        {
            "timestamp": [
                24.7,
                28.46
            ],
            "text": " Reverse number into 10 plus last digit."
        },
        {
            "timestamp": [
                28.76,
                29.92
            ],
            "text": " Let's see how it works."
        },
        {
            "timestamp": [
                0.0,
                5.48
            ],
            "text": " So I'm saying initially reverse number is 0 to start off."
        },
        {
            "timestamp": [
                5.96,
                7.1
            ],
            "text": " Let's do the step by step."
        },
        {
            "timestamp": [
                7.58,
                9.8
            ],
            "text": " First step, 9 gets generated."
        },
        {
            "timestamp": [
                10.28,
                16.5
            ],
            "text": " So what am I doing is 0 into 10 because reverse number is 0 at the first step."
        },
        {
            "timestamp": [
                16.88,
                22.28
            ],
            "text": " At the first step, 7-789 Moduro 10 will generate 9."
        },
        {
            "timestamp": [
                22.92,
                28.78
            ],
            "text": " And N would have as of now become something like 7-7-8-9 by 10."
        },
        {
            "timestamp": [
                0.0,
                3.06
            ],
            "text": " So n would have as of now become 7, 7, 7, 8."
        },
        {
            "timestamp": [
                3.68,
                9.64
            ],
            "text": " And reverse number says reverse number is 0 into 10 plus the last digit 9."
        },
        {
            "timestamp": [
                10.3,
                15.88
            ],
            "text": " So the number becomes, or rather the reverse number as of now is 9."
        },
        {
            "timestamp": [
                16.34,
                16.56
            ],
            "text": " Right."
        },
        {
            "timestamp": [
                16.96,
                18.4
            ],
            "text": " This is what the first iteration is."
        },
        {
            "timestamp": [
                18.78,
                19.88
            ],
            "text": " Let's do the next iteration."
        },
        {
            "timestamp": [
                20.42,
                24.58
            ],
            "text": " So the next iteration will be, I'll just quickly omit this off."
        },
        {
            "timestamp": [
                25.48,
                29.4
            ],
            "text": " So in the next iteration, can I say it's 778,"
        },
        {
            "timestamp": [
                0.0,
                3.38
            ],
            "text": " greater than 0 and 778"
        },
        {
            "timestamp": [
                3.38,
                4.82
            ],
            "text": " Modulo 10"
        },
        {
            "timestamp": [
                4.82,
                6.72
            ],
            "text": " hence the last digit is 8"
        },
        {
            "timestamp": [
                6.72,
                9.54
            ],
            "text": " I can say this and this will be 778"
        },
        {
            "timestamp": [
                9.54,
                11.78
            ],
            "text": " by 10 so N will become"
        },
        {
            "timestamp": [
                11.78,
                14.08
            ],
            "text": " 707 this time"
        },
        {
            "timestamp": [
                14.08,
                16.58
            ],
            "text": " reverse number is stored as 9"
        },
        {
            "timestamp": [
                16.58,
                18.54
            ],
            "text": " because you stored reverse number"
        },
        {
            "timestamp": [
                18.54,
                20.62
            ],
            "text": " as this value so this is 9"
        },
        {
            "timestamp": [
                20.62,
                23.58
            ],
            "text": " so what do you do is you say 9 into 10"
        },
        {
            "timestamp": [
                24.96,
                26.68
            ],
            "text": " plus the last digit 8"
        },
        {
            "timestamp": [
                26.68,
                29.46
            ],
            "text": " so what do you get is 9 into 10"
        },
        {
            "timestamp": [
                0.0,
                3.64
            ],
            "text": " plus the last digit 8, which makes it 98."
        },
        {
            "timestamp": [
                4.14,
                6.3
            ],
            "text": " The next time you get 7,"
        },
        {
            "timestamp": [
                6.84,
                12.26
            ],
            "text": " the reverse says 98 into 10 plus 7, which is 98."
        },
        {
            "timestamp": [
                12.26,
                21.18
            ],
            "text": " Next time it is 7, the 987 into 10 plus 7 is 987."
        },
        {
            "timestamp": [
                22.08,
                23.76
            ],
            "text": " So you got the reverse number at that."
        },
        {
            "timestamp": [
                24.6,
                25.3
            ],
            "text": " Why it's simple?"
        },
        {
            "timestamp": [
                25.84,
                26.9
            ],
            "text": " Why did this work?"
        },
        {
            "timestamp": [
                27.24,
                27.98
            ],
            "text": " It is very easy."
        },
        {
            "timestamp": [
                28.68,
                29.1
            ],
            "text": " Understand."
        },
        {
            "timestamp": [
                0.0,
                6.32
            ],
            "text": " you are getting in last digit you're easily getting the last digit nine and after that you're"
        },
        {
            "timestamp": [
                6.32,
                12.4
            ],
            "text": " getting the next last digit eight and you somehow want to add eight to that nine you somehow want"
        },
        {
            "timestamp": [
                12.4,
                18.72
            ],
            "text": " to add eight to that nine and the easiest way is if you can somehow add a zero to this nine"
        },
        {
            "timestamp": [
                18.72,
                25.44
            ],
            "text": " it will become 90 and then if you add eight to it it will become 98 similarly if you want to add"
        },
        {
            "timestamp": [
                25.44,
                29.98
            ],
            "text": " seven to it if you want to add a seven to it make it nine eighty seven you are again again"
        },
        {
            "timestamp": [
                0.0,
                6.36
            ],
            "text": " add a 0 and then a 7 to 8 it becomes 987 again if you want to add a 7 you again add a 0"
        },
        {
            "timestamp": [
                6.36,
                13.76
            ],
            "text": " this is why at every step i am doing reverse number into 10 whatever you have generated"
        },
        {
            "timestamp": [
                13.76,
                20.24
            ],
            "text": " into 10 that will allow the last unit digit to be 0 then when you add a digit goes and gets into"
        },
        {
            "timestamp": [
                20.24,
                28.8
            ],
            "text": " that place as simple as that so again you saw that extraction of digits is actually handy so"
        },
        {
            "timestamp": [
                0.0,
                6.5
            ],
            "text": " So what I'll do is I'll take the number and I'll keep the reverse num equal to 0."
        },
        {
            "timestamp": [
                6.5,
                9.5
            ],
            "text": " And then I'll go ahead and say n greater than 0."
        },
        {
            "timestamp": [
                9.5,
                13.4
            ],
            "text": " And I can say last digit is N modulo 10."
        },
        {
            "timestamp": [
                13.4,
                19.0
            ],
            "text": " I can say reverse number is reverse number into 10 plus last digit."
        },
        {
            "timestamp": [
                19.0,
                27.0
            ],
            "text": " And I can say n is n by 10 and the same time I can say C out of reverse number is what I need."
        },
        {
            "timestamp": [
                27.0,
                28.0
            ],
            "text": " Perfect."
        },
        {
            "timestamp": [
                28.0,
                29.98
            ],
            "text": " And I'll quickly run the code and see if it is right."
        },
        {
            "timestamp": [
                0.0,
                5.38
            ],
            "text": " running fine it is let's quickly submit this and this should be running fine this dead so"
        },
        {
            "timestamp": [
                5.38,
                12.04
            ],
            "text": " so reverse a number is salt again with the concept of extraction of digits next problem is check"
        },
        {
            "timestamp": [
                12.04,
                17.64
            ],
            "text": " palindrom now when I go to the palindrome problem let's understand the problem it states"
        },
        {
            "timestamp": [
                17.64,
                24.12
            ],
            "text": " write a program to determine if a given number is palindrome or not print true if it is palindrom"
        },
        {
            "timestamp": [
                24.12,
                29.98
            ],
            "text": " or false otherwise so overhead states palindrom are the numbers for which"
        },
        {
            "timestamp": [
                0.0,
                2.96
            ],
            "text": " reverse is exactly same as the original one."
        },
        {
            "timestamp": [
                3.16,
                4.24
            ],
            "text": " For an example, one to one."
        },
        {
            "timestamp": [
                4.8,
                8.0
            ],
            "text": " Because if you take one to one and you do a reverse of it,"
        },
        {
            "timestamp": [
                8.54,
                10.04
            ],
            "text": " one to one's reverse is one to one."
        },
        {
            "timestamp": [
                10.54,
                12.84
            ],
            "text": " That is why it is called as palindrop."
        },
        {
            "timestamp": [
                13.14,
                17.92
            ],
            "text": " So if I go to the iPad and write some other palindrum numbers,"
        },
        {
            "timestamp": [
                18.32,
                19.88
            ],
            "text": " it's like one-double-three-one."
        },
        {
            "timestamp": [
                20.32,
                24.62
            ],
            "text": " If you write the reverse of it, it stays still one-double-three-one."
        },
        {
            "timestamp": [
                25.04,
                25.98
            ],
            "text": " Something like 11."
        },
        {
            "timestamp": [
                26.36,
                28.46
            ],
            "text": " 11 in itself is a palindrop."
        },
        {
            "timestamp": [
                28.72,
                29.18
            ],
            "text": " 7."
        },
        {
            "timestamp": [
                0.0,
                7.2
            ],
            "text": " 7 in itself is a palindrome whereas 1 to 3 the reverse of 1 2 3 to 1 this is not a palindrome"
        },
        {
            "timestamp": [
                7.2,
                13.84
            ],
            "text": " so any number which on reversal is the same number is a palindrome number so the definition of"
        },
        {
            "timestamp": [
                13.84,
                19.84
            ],
            "text": " palindrome number says reverse of a number so if i somehow can generate the reverse of a number"
        },
        {
            "timestamp": [
                19.84,
                25.36
            ],
            "text": " if i somehow can generate the reverse of a number which i've already did and then compare it with"
        },
        {
            "timestamp": [
                25.36,
                29.68
            ],
            "text": " the original n if they come out to be same can i say they are palindrome"
        },
        {
            "timestamp": [
                0.0,
                0.46
            ],
            "text": " I can."
        },
        {
            "timestamp": [
                0.98,
                3.74
            ],
            "text": " So over here if you remember, we took a reverse number."
        },
        {
            "timestamp": [
                4.24,
                8.62
            ],
            "text": " And at the end of the day, the reverse number was nothing but the reverse number."
        },
        {
            "timestamp": [
                9.24,
                15.8
            ],
            "text": " And now, if I can compare this reverse number with the original number, with the original number, which is N,"
        },
        {
            "timestamp": [
                16.32,
                18.36
            ],
            "text": " and if they come out to be same, I can say it as palindrome."
        },
        {
            "timestamp": [
                18.92,
                23.3
            ],
            "text": " Like, if this is true, I can say this palindrome or I can say it is not palan."
        },
        {
            "timestamp": [
                23.7,
                24.28
            ],
            "text": " Can I see that?"
        },
        {
            "timestamp": [
                24.72,
                26.14
            ],
            "text": " But wait, wait."
        },
        {
            "timestamp": [
                26.72,
                29.98
            ],
            "text": " If you remember, we were dividing n by 10."
        },
        {
            "timestamp": [
                0.0,
                1.72
            ],
            "text": " and at the end of the day,"
        },
        {
            "timestamp": [
                2.2,
                3.5
            ],
            "text": " n was zero."
        },
        {
            "timestamp": [
                4.08,
                5.66
            ],
            "text": " So does N"
        },
        {
            "timestamp": [
                5.66,
                7.74
            ],
            "text": " have the original number?"
        },
        {
            "timestamp": [
                8.04,
                11.36
            ],
            "text": " No, because we are doing operations with N"
        },
        {
            "timestamp": [
                11.36,
                14.66
            ],
            "text": " which has made N to be zero at the end of the day."
        },
        {
            "timestamp": [
                15.26,
                16.54
            ],
            "text": " So what I need to do is"
        },
        {
            "timestamp": [
                16.54,
                19.92
            ],
            "text": " maybe I need to store a duplicate of N"
        },
        {
            "timestamp": [
                19.92,
                22.34
            ],
            "text": " in some double variable."
        },
        {
            "timestamp": [
                22.88,
                24.78
            ],
            "text": " And instead of comparing it with N,"
        },
        {
            "timestamp": [
                24.78,
                26.86
            ],
            "text": " I can compare it with a duplicate"
        },
        {
            "timestamp": [
                26.86,
                29.16
            ],
            "text": " because N will"
        },
        {
            "timestamp": [
                0.0,
                3.9
            ],
            "text": " p0 at the end of the extraction of digits."
        },
        {
            "timestamp": [
                4.32,
                10.76
            ],
            "text": " It's very important to store a copy of n somewhere so that it can be used to compare it with the"
        },
        {
            "timestamp": [
                10.76,
                11.58
            ],
            "text": " reverse of a number."
        },
        {
            "timestamp": [
                11.96,
                13.64
            ],
            "text": " That is the only change that you have to do."
        },
        {
            "timestamp": [
                13.92,
                15.54
            ],
            "text": " That is the only thing that you have to keep in the mind."
        },
        {
            "timestamp": [
                15.66,
                19.12
            ],
            "text": " So if remember this was the code, so what I'll do is I'll just go ahead and say duplicate"
        },
        {
            "timestamp": [
                19.12,
                24.12
            ],
            "text": " equal to n and over here I say if dupe is equal to reverse number."
        },
        {
            "timestamp": [
                24.12,
                29.76
            ],
            "text": " I can go ahead and print true, which is what they want, which is true or else."
        },
        {
            "timestamp": [
                0.0,
                7.76
            ],
            "text": " else you can just go ahead and print that is what they required if there's small"
        },
        {
            "timestamp": [
                7.76,
                12.24
            ],
            "text": " well quickly run it and see if it is running fine should be and let's quickly submit this"
        },
        {
            "timestamp": [
                12.24,
                19.92
            ],
            "text": " on submitting you see that it is running absolutely fine next one is gcd or hcf but before"
        },
        {
            "timestamp": [
                19.92,
                24.8
            ],
            "text": " that we will be solving armstrong numbers so what is the definition of armstrong number"
        },
        {
            "timestamp": [
                24.8,
                29.98
            ],
            "text": " it's very simple imagine you're given this number 371 you take three"
        },
        {
            "timestamp": [
                0.0,
                13.58
            ],
            "text": " cube, 7 cube plus 1 cube. If taking the cubes of these numbers, like cubes of these digits and adding them up, sums up to the number itself, that is what you call as an Armstrong number."
        },
        {
            "timestamp": [
                13.58,
                22.88
            ],
            "text": " Even if you take 1634, 1 cube plus 6 cube plus 3 cube plus 4 cube, if you sum them up, you actually get 1634."
        },
        {
            "timestamp": [
                23.3,
                29.98
            ],
            "text": " But something like 35, if you take 3 cube plus 5 cube, this is not going to be equal to."
        },
        {
            "timestamp": [
                0.0,
                8.8
            ],
            "text": " 35 this is going to be equal to 134 so this and this are not same whereas 1634 and the summation"
        },
        {
            "timestamp": [
                8.8,
                16.72
            ],
            "text": " of cubes of its digits is 1634 so you call 1634 as an armstrong number or 371 as an"
        },
        {
            "timestamp": [
                16.72,
                20.8
            ],
            "text": " armstrong number so i hope you've got the definition of armstrong number if you have got the"
        },
        {
            "timestamp": [
                20.8,
                25.6
            ],
            "text": " definition of armstrong number you know how to solve it i've already taught you the extraction of"
        },
        {
            "timestamp": [
                25.6,
                29.52
            ],
            "text": " digits you know how do you extract nine you know how do you extract eight"
        },
        {
            "timestamp": [
                0.0,
                1.6
            ],
            "text": " You know how do you extract 7?"
        },
        {
            "timestamp": [
                2.56,
                3.88
            ],
            "text": " Just have to do a cube of it."
        },
        {
            "timestamp": [
                4.46,
                9.8
            ],
            "text": " So can I see this time, instead of taking any such duplicate or reverse n,"
        },
        {
            "timestamp": [
                10.42,
                13.78
            ],
            "text": " I can just take a summation because I need to sum cubes."
        },
        {
            "timestamp": [
                14.44,
                16.38
            ],
            "text": " And last digit is what I have to sum."
        },
        {
            "timestamp": [
                17.02,
                23.06
            ],
            "text": " Can I say sum equal to sum plus last digit multiplied thrice?"
        },
        {
            "timestamp": [
                23.64,
                26.04
            ],
            "text": " Last digit into last digit into last digit."
        },
        {
            "timestamp": [
                26.14,
                26.74
            ],
            "text": " Can I do this?"
        },
        {
            "timestamp": [
                27.44,
                29.22
            ],
            "text": " So first time nine comes in."
        },
        {
            "timestamp": [
                0.0,
                0.92
            ],
            "text": " What happens?"
        },
        {
            "timestamp": [
                1.44,
                5.26
            ],
            "text": " 9 into 9 into 9 gets added to sum."
        },
        {
            "timestamp": [
                5.76,
                10.52
            ],
            "text": " Next time 8 comes in, 8 into 8 into 8 gets added to the sum."
        },
        {
            "timestamp": [
                11.0,
                12.36
            ],
            "text": " So everything is getting added."
        },
        {
            "timestamp": [
                12.96,
                17.6
            ],
            "text": " First time, 9 into 9, sorry, 9 into 9 into 9 got here."
        },
        {
            "timestamp": [
                18.06,
                20.38
            ],
            "text": " Next time 8 went 8 into 8 into 8."
        },
        {
            "timestamp": [
                20.82,
                23.16
            ],
            "text": " Next time 7 came in, 7 into 7."
        },
        {
            "timestamp": [
                23.58,
                25.9
            ],
            "text": " Next time again 7 came in 7 to 7 into 7."
        },
        {
            "timestamp": [
                26.18,
                28.14
            ],
            "text": " So can I say at the end of the day,"
        },
        {
            "timestamp": [
                0.0,
                8.8
            ],
            "text": " some will be storing the summation of digit cubes and after that you need to just compare it with the original end"
        },
        {
            "timestamp": [
                8.8,
                14.16
            ],
            "text": " so maybe again keep a duplicate variable which stores the end because at the end of the day"
        },
        {
            "timestamp": [
                14.16,
                20.8
            ],
            "text": " you have to compare if this and the duplicate are same if this is then you say it is an arm strong if this is"
        },
        {
            "timestamp": [
                20.8,
                27.68
            ],
            "text": " not it's not an arm's again what logic worked extraction of digits if you know how to extract digits"
        },
        {
            "timestamp": [
                0.0,
                2.64
            ],
            "text": " You can play around with them and you can solve this problem."
        },
        {
            "timestamp": [
                3.3,
                7.44
            ],
            "text": " So Armstrong number is completed and the next problem that we'll be doing is"
        },
        {
            "timestamp": [
                7.44,
                9.5
            ],
            "text": " print all divisors."
        },
        {
            "timestamp": [
                9.86,
                12.6
            ],
            "text": " So when I say print all divisors, what does it mean?"
        },
        {
            "timestamp": [
                12.94,
                14.64
            ],
            "text": " Imagine I take a number like 36."
        },
        {
            "timestamp": [
                15.14,
                17.88
            ],
            "text": " Now ask you, what are all the numbers that divide 36?"
        },
        {
            "timestamp": [
                18.68,
                22.0
            ],
            "text": " So you can say one is something which completely divides 36."
        },
        {
            "timestamp": [
                22.62,
                25.58
            ],
            "text": " You can say two is something which completely divides 36."
        },
        {
            "timestamp": [
                25.96,
                29.26
            ],
            "text": " You can again say three is something which completely divides 36."
        },
        {
            "timestamp": [
                0.0,
                8.06
            ],
            "text": " 4 is something which completely divides is 5 something which completely divides 36 no if 36 is divided 5"
        },
        {
            "timestamp": [
                8.06,
                15.94
            ],
            "text": " it leaves a remainder of 1 so not 5 6 is something which does it 9 is something which in does it"
        },
        {
            "timestamp": [
                15.94,
                22.86
            ],
            "text": " and 12 is something which does it then 18 is something which does it and then 36 is something which does"
        },
        {
            "timestamp": [
                22.86,
                29.98
            ],
            "text": " so if I talk about 36 the divisions of 36 are 1 2 3 4 6 9 12 18"
        },
        {
            "timestamp": [
                0.0,
                1.82
            ],
            "text": " and 36."
        },
        {
            "timestamp": [
                2.22,
                3.68
            ],
            "text": " These are the divisors of"
        },
        {
            "timestamp": [
                3.68,
                5.84
            ],
            "text": " 36. The question is very"
        },
        {
            "timestamp": [
                5.84,
                7.54
            ],
            "text": " straightforward. You have to print"
        },
        {
            "timestamp": [
                7.54,
                9.96
            ],
            "text": " all of them in this particular"
        },
        {
            "timestamp": [
                9.96,
                10.92
            ],
            "text": " order. Okay?"
        },
        {
            "timestamp": [
                11.64,
                13.18
            ],
            "text": " Now, how do I do?"
        },
        {
            "timestamp": [
                13.66,
                16.06
            ],
            "text": " It's very simple. One thing I know"
        },
        {
            "timestamp": [
                16.06,
                18.14
            ],
            "text": " for sure is, if I'm talking about"
        },
        {
            "timestamp": [
                18.14,
                19.76
            ],
            "text": " divisors or factors,"
        },
        {
            "timestamp": [
                20.32,
                21.98
            ],
            "text": " they're definitely going to lie between"
        },
        {
            "timestamp": [
                21.98,
                23.9
            ],
            "text": " one to the number itself."
        },
        {
            "timestamp": [
                24.62,
                25.96
            ],
            "text": " Can I say all the"
        },
        {
            "timestamp": [
                25.96,
                27.62
            ],
            "text": " divisors will be between"
        },
        {
            "timestamp": [
                27.62,
                29.9
            ],
            "text": " one to and itself, because"
        },
        {
            "timestamp": [
                0.0,
                7.2
            ],
            "text": " anything greater than n will never divide n for sure so if i know all the divisors are going to be between"
        },
        {
            "timestamp": [
                7.68,
                14.24
            ],
            "text": " one and n can i just loop from one to n that's my first thought process since i know the"
        },
        {
            "timestamp": [
                14.24,
                19.6
            ],
            "text": " divisors are from one to n my first thought process is very simple so let's do one let's start the"
        },
        {
            "timestamp": [
                19.6,
                26.8
            ],
            "text": " loop from i equal to one i lesser than equal to n and i plus plus this is something i know for sure"
        },
        {
            "timestamp": [
                0.0,
                2.12
            ],
            "text": " So I is used to loop around."
        },
        {
            "timestamp": [
                2.62,
                8.2
            ],
            "text": " Now the first value of I is 1, then it's 2, then it's 3, then it's 4, then it's 5, and then so on till 36."
        },
        {
            "timestamp": [
                8.3,
                10.28
            ],
            "text": " In this case, if it is n."
        },
        {
            "timestamp": [
                10.88,
                15.36
            ],
            "text": " So how do you determine that this I is a part of all the divisions?"
        },
        {
            "timestamp": [
                16.06,
                16.6
            ],
            "text": " It's very simple."
        },
        {
            "timestamp": [
                17.26,
                29.42
            ],
            "text": " Can I say if it is completely dividing, if I is completely dividing n, then it is a factor or a divisor?"
        },
        {
            "timestamp": [
                0.0,
                1.64
            ],
            "text": " And what do you mean by completely dividing?"
        },
        {
            "timestamp": [
                2.3,
                3.64
            ],
            "text": " It should leave a remainder of 0."
        },
        {
            "timestamp": [
                4.2,
                6.18
            ],
            "text": " When I say leaving a remainder of 0,"
        },
        {
            "timestamp": [
                6.68,
                9.52
            ],
            "text": " does it mean if I do a modulated of I?"
        },
        {
            "timestamp": [
                10.42,
                16.22
            ],
            "text": " If I do N modulo I, the value should be 0 because it's completely divisible."
        },
        {
            "timestamp": [
                16.52,
                23.22
            ],
            "text": " By what I will do is, I'll say, okay, if N modulo I is equal to equal to 0,"
        },
        {
            "timestamp": [
                23.72,
                27.98
            ],
            "text": " I will go ahead and print I in C++ plus see out in Java system.com."
        },
        {
            "timestamp": [
                0.0,
                6.24
            ],
            "text": " dot print and I'll go ahead and print out in this way I'll be able to print all the factors"
        },
        {
            "timestamp": [
                6.24,
                12.56
            ],
            "text": " of a particular n if I talk about the time complexity ask you what is the time complexity of"
        },
        {
            "timestamp": [
                12.56,
                17.52
            ],
            "text": " this code you'll be like striver it's very simple since the loop is running from one to n"
        },
        {
            "timestamp": [
                17.52,
                23.92
            ],
            "text": " it's taking n iterations and this is an unit operation so let's not compare calculated"
        },
        {
            "timestamp": [
                23.92,
                29.84
            ],
            "text": " thereby the time complexity of this particular approach is nothing but we go off and very"
        },
        {
            "timestamp": [
                0.0,
                2.0
            ],
            "text": " Over here they've given us everything."
        },
        {
            "timestamp": [
                2.0,
                5.0
            ],
            "text": " They want us to write this print divisors function."
        },
        {
            "timestamp": [
                5.0,
                7.0
            ],
            "text": " Let's write the print divisors function."
        },
        {
            "timestamp": [
                7.0,
                8.0
            ],
            "text": " It takes an n."
        },
        {
            "timestamp": [
                8.0,
                10.0
            ],
            "text": " And as I said, it's very simple."
        },
        {
            "timestamp": [
                10.0,
                13.0
            ],
            "text": " You go from 1, you go on till n."
        },
        {
            "timestamp": [
                13.0,
                15.0
            ],
            "text": " And you say I, this one."
        },
        {
            "timestamp": [
                15.0,
                18.0
            ],
            "text": " And you know if n modulo i is equal to equal to 0,"
        },
        {
            "timestamp": [
                18.0,
                22.0
            ],
            "text": " you say see out, I, and then you give a bit of space."
        },
        {
            "timestamp": [
                22.0,
                24.0
            ],
            "text": " That's what you need to write."
        },
        {
            "timestamp": [
                24.0,
                29.0
            ],
            "text": " And on submitting, you will see that this is running absolutely fine."
        },
        {
            "timestamp": [
                0.0,
                8.4
            ],
            "text": " fine but the time complexity is bgo of n i don't want a bgo of n time complexity can i do it in a much"
        },
        {
            "timestamp": [
                8.4,
                14.0
            ],
            "text": " better way i can't but it requires a bit of mathematical observation let's see that mathematical"
        },
        {
            "timestamp": [
                14.0,
                22.24
            ],
            "text": " observation so for 36 i said that one was a factor if one is a factor one has to be multiplied"
        },
        {
            "timestamp": [
                22.24,
                29.98
            ],
            "text": " with something in order to get 36 so one was multiplied with 30 and if you carefully observe"
        },
        {
            "timestamp": [
                0.0,
                29.98
            ],
            "text": " if this is 1 and the number is 36 the other number will always be n by 1 very simple if it is 2 the other number will be n by 2 which is 36 by 2 that means 18 so you get 18 the next time it was 3 so the next time it is 3 it is nothing but 12 36 by 3 because 3 into 12 will be 36 the next time when I take 3 it is nothing but 12 36 by 3 because 3 into 12 will be 36 the next time when I"
        },
        {
            "timestamp": [
                0.0,
                7.84
            ],
            "text": " take 4, it is 4 into 9. The next time when I take 6, it is 6 into 6. Next time, the next factor"
        },
        {
            "timestamp": [
                7.84,
                15.48
            ],
            "text": " is actually 9 and then you multiply it with 4. And the next factor is 12 and you multiply it with 3."
        },
        {
            "timestamp": [
                15.48,
                22.78
            ],
            "text": " And the next factor is 18, you multiply it with 2. And the next time it is 36, you multiply it with 1."
        },
        {
            "timestamp": [
                23.2,
                27.86
            ],
            "text": " So if I, if I have to write all the factors, these are all the factors. These are all the factors."
        },
        {
            "timestamp": [
                0.0,
                7.5
            ],
            "text": " definitely all the factors right but do you have a bit of observation if I draw a"
        },
        {
            "timestamp": [
                7.5,
                18.54
            ],
            "text": " line at this portion if I draw a line at this portion and I take this and I take"
        },
        {
            "timestamp": [
                18.54,
                27.72
            ],
            "text": " this aren't they equal 1 into 36 36 into 1 so can I see even if I consider"
        },
        {
            "timestamp": [
                0.0,
                2.92
            ],
            "text": " everything before the orange line"
        },
        {
            "timestamp": [
                2.92,
                4.24
            ],
            "text": " I will get one"
        },
        {
            "timestamp": [
                4.24,
                5.84
            ],
            "text": " I'll get two"
        },
        {
            "timestamp": [
                5.84,
                7.44
            ],
            "text": " I'll get three"
        },
        {
            "timestamp": [
                7.44,
                9.06
            ],
            "text": " I'll get four"
        },
        {
            "timestamp": [
                9.06,
                10.64
            ],
            "text": " I'll get 16"
        },
        {
            "timestamp": [
                10.64,
                11.52
            ],
            "text": " sorry six"
        },
        {
            "timestamp": [
                11.52,
                12.84
            ],
            "text": " I'll get 9"
        },
        {
            "timestamp": [
                12.84,
                14.38
            ],
            "text": " I'll get 12"
        },
        {
            "timestamp": [
                14.38,
                15.92
            ],
            "text": " I'll get 18"
        },
        {
            "timestamp": [
                15.92,
                17.22
            ],
            "text": " and I'll get 36"
        },
        {
            "timestamp": [
                17.22,
                19.48
            ],
            "text": " even if I take everything"
        },
        {
            "timestamp": [
                19.48,
                20.42
            ],
            "text": " before the orange line"
        },
        {
            "timestamp": [
                20.42,
                22.38
            ],
            "text": " even if I take everything"
        },
        {
            "timestamp": [
                22.38,
                23.64
            ],
            "text": " before this orange line"
        },
        {
            "timestamp": [
                23.64,
                25.14
            ],
            "text": " do I get all the fact"
        },
        {
            "timestamp": [
                25.14,
                26.04
            ],
            "text": " I do"
        },
        {
            "timestamp": [
                26.04,
                29.02
            ],
            "text": " so do I need to go beyond this orange line"
        },
        {
            "timestamp": [
                29.02,
                29.82
            ],
            "text": " no"
        },
        {
            "timestamp": [
                0.0,
                1.56
            ],
            "text": " So what is this orange line?"
        },
        {
            "timestamp": [
                2.08,
                4.78
            ],
            "text": " If you carefully observe, what are you doing?"
        },
        {
            "timestamp": [
                5.12,
                7.22
            ],
            "text": " A small number into a big number."
        },
        {
            "timestamp": [
                7.62,
                9.44
            ],
            "text": " A small number into a big number."
        },
        {
            "timestamp": [
                9.88,
                11.16
            ],
            "text": " A small number into a big number."
        },
        {
            "timestamp": [
                11.72,
                13.62
            ],
            "text": " Same number."
        },
        {
            "timestamp": [
                14.42,
                16.72
            ],
            "text": " And then a big into small."
        },
        {
            "timestamp": [
                17.3,
                18.4
            ],
            "text": " A big into small."
        },
        {
            "timestamp": [
                18.92,
                19.84
            ],
            "text": " A big into small."
        },
        {
            "timestamp": [
                19.84,
                19.86
            ],
            "text": " A big into small."
        },
        {
            "timestamp": [
                20.56,
                24.86
            ],
            "text": " So can I see this is nothing but the square root of n."
        },
        {
            "timestamp": [
                25.44,
                27.14
            ],
            "text": " Because when you take square root of n,"
        },
        {
            "timestamp": [
                27.82,
                29.3
            ],
            "text": " square root of 36 is 6."
        },
        {
            "timestamp": [
                0.0,
                4.4
            ],
            "text": " beyond square root, the numbers will grow, the numbers will grow"
        },
        {
            "timestamp": [
                4.4,
                8.2
            ],
            "text": " and it will nothing but a replication of the upper half,"
        },
        {
            "timestamp": [
                8.2,
                10.2
            ],
            "text": " the replication of the upper half."
        },
        {
            "timestamp": [
                10.2,
                14.8
            ],
            "text": " So thereby, this is nothing but a repetition of the upper half,"
        },
        {
            "timestamp": [
                14.8,
                16.6
            ],
            "text": " thereby I can say,"
        },
        {
            "timestamp": [
                16.6,
                19.4
            ],
            "text": " even if you loop till square root of n,"
        },
        {
            "timestamp": [
                19.4,
                21.4
            ],
            "text": " even if you loop till square root of n,"
        },
        {
            "timestamp": [
                21.4,
                23.4
            ],
            "text": " you actually can get your factors."
        },
        {
            "timestamp": [
                23.4,
                24.4
            ],
            "text": " How?"
        },
        {
            "timestamp": [
                24.4,
                27.8
            ],
            "text": " If this is 1, this has to be n by 1."
        },
        {
            "timestamp": [
                0.0,
                2.88
            ],
            "text": " If this is 2, this has to be n by 2."
        },
        {
            "timestamp": [
                3.38,
                5.6
            ],
            "text": " If this is 3, this has to be n by 3."
        },
        {
            "timestamp": [
                6.02,
                7.9
            ],
            "text": " If this is 4, this has to be n by 4."
        },
        {
            "timestamp": [
                8.38,
                11.04
            ],
            "text": " If this is 6, this has to be n by 6."
        },
        {
            "timestamp": [
                11.56,
                14.96
            ],
            "text": " So can I say, now the looping is going to be very straightforward."
        },
        {
            "timestamp": [
                15.76,
                23.42
            ],
            "text": " I loop from i equal to 1 till i less than equal to square root of n and i plus plus?"
        },
        {
            "timestamp": [
                24.1,
                24.52
            ],
            "text": " Can I do?"
        },
        {
            "timestamp": [
                25.16,
                28.56
            ],
            "text": " And can I say if n modulo i is a factor?"
        },
        {
            "timestamp": [
                0.0,
                3.16
            ],
            "text": " Then print I as one of the factors."
        },
        {
            "timestamp": [
                3.8,
                5.14
            ],
            "text": " Print I as one of the factors."
        },
        {
            "timestamp": [
                5.54,
                6.46
            ],
            "text": " What is the other factor?"
        },
        {
            "timestamp": [
                6.92,
                10.28
            ],
            "text": " We just now found out the other factor was N by I."
        },
        {
            "timestamp": [
                10.64,
                11.62
            ],
            "text": " But we need to be careful."
        },
        {
            "timestamp": [
                12.26,
                13.52
            ],
            "text": " What is the careful observation?"
        },
        {
            "timestamp": [
                14.3,
                17.08
            ],
            "text": " If it is 6, the other factor might be 6."
        },
        {
            "timestamp": [
                17.56,
                19.16
            ],
            "text": " So there are not two different factors."
        },
        {
            "timestamp": [
                19.7,
                21.54
            ],
            "text": " So if you're taking the second factor,"
        },
        {
            "timestamp": [
                22.1,
                24.54
            ],
            "text": " if you're taking the second factor to N by I,"
        },
        {
            "timestamp": [
                25.06,
                28.3
            ],
            "text": " just make sure that N by I is not equal to I."
        },
        {
            "timestamp": [
                0.0,
                3.26
            ],
            "text": " because the second factor might turn out to be the same factor."
        },
        {
            "timestamp": [
                3.7,
                4.54
            ],
            "text": " It's very important."
        },
        {
            "timestamp": [
                4.92,
                8.5
            ],
            "text": " The N by I, which is the second factor, must be compared with I."
        },
        {
            "timestamp": [
                8.76,
                11.68
            ],
            "text": " And if they are not same, you can say that, maybe print."
        },
        {
            "timestamp": [
                12.9,
                14.26
            ],
            "text": " That's your another factor."
        },
        {
            "timestamp": [
                15.66,
                16.1
            ],
            "text": " That's it."
        },
        {
            "timestamp": [
                17.3,
                20.98
            ],
            "text": " So first, check if I is a factor, printed."
        },
        {
            "timestamp": [
                21.52,
                26.36
            ],
            "text": " Now, the other factor, N by I, with which the I will be multiplied,"
        },
        {
            "timestamp": [
                27.08,
                29.98
            ],
            "text": " just check if this is not equal to I."
        },
        {
            "timestamp": [
                0.0,
                2.18
            ],
            "text": " If it is not, that's the second factor."
        },
        {
            "timestamp": [
                2.76,
                3.14
            ],
            "text": " That's it."
        },
        {
            "timestamp": [
                3.44,
                7.42
            ],
            "text": " So if you go ahead and print this, the printing will be something like this."
        },
        {
            "timestamp": [
                7.78,
                10.08
            ],
            "text": " First one and 36 will get printed."
        },
        {
            "timestamp": [
                10.62,
                12.6
            ],
            "text": " Next two and 18 will get printed."
        },
        {
            "timestamp": [
                13.14,
                15.9
            ],
            "text": " Next, three and 12 will get printed."
        },
        {
            "timestamp": [
                16.36,
                18.62
            ],
            "text": " Next four and nine will get printed."
        },
        {
            "timestamp": [
                19.04,
                20.14
            ],
            "text": " Next one is six."
        },
        {
            "timestamp": [
                20.54,
                21.5
            ],
            "text": " Six gets printed."
        },
        {
            "timestamp": [
                22.02,
                23.4
            ],
            "text": " But the other factor is six."
        },
        {
            "timestamp": [
                24.24,
                26.3
            ],
            "text": " And it fails this condition check."
        },
        {
            "timestamp": [
                26.74,
                28.98
            ],
            "text": " Thereby, the other six doesn't get printed."
        },
        {
            "timestamp": [
                29.46,
                29.98
            ],
            "text": " So all the fact is six."
        },
        {
            "timestamp": [
                0.0,
                6.58
            ],
            "text": " factors are printed but they are not printed in a proper yes they're not printed in a"
        },
        {
            "timestamp": [
                6.58,
                12.46
            ],
            "text": " sorted way so what you can do is whenever you are getting all the factors probably you can"
        },
        {
            "timestamp": [
                12.46,
                18.46
            ],
            "text": " store them into a data structure and if you have seen the c++ stl video you know which data"
        },
        {
            "timestamp": [
                18.46,
                24.46
            ],
            "text": " structure you can use you do not know what will be the size or what will be the number of"
        },
        {
            "timestamp": [
                24.46,
                29.98
            ],
            "text": " factors so the data structure that you will be using is a list a list in charge"
        },
        {
            "timestamp": [
                0.0,
                2.44
            ],
            "text": " or a vector in C++."
        },
        {
            "timestamp": [
                3.08,
                5.18
            ],
            "text": " We'll be using an undefined."
        },
        {
            "timestamp": [
                5.3,
                7.5
            ],
            "text": " Like you cannot define the size of the data structure."
        },
        {
            "timestamp": [
                7.86,
                9.04
            ],
            "text": " We'll be using a list."
        },
        {
            "timestamp": [
                9.54,
                9.72
            ],
            "text": " Okay."
        },
        {
            "timestamp": [
                10.14,
                12.0
            ],
            "text": " And in that list, you can store it."
        },
        {
            "timestamp": [
                12.08,
                12.82
            ],
            "text": " You can store it."
        },
        {
            "timestamp": [
                13.0,
                14.1
            ],
            "text": " You can store, store, store, store."
        },
        {
            "timestamp": [
                14.64,
                17.0
            ],
            "text": " So everything will be stored in the list."
        },
        {
            "timestamp": [
                17.46,
                18.88
            ],
            "text": " Once you have stored in the list,"
        },
        {
            "timestamp": [
                19.64,
                20.42
            ],
            "text": " sort the list."
        },
        {
            "timestamp": [
                20.94,
                24.98
            ],
            "text": " And if you sort the list, you will get everything in the sorted fashion."
        },
        {
            "timestamp": [
                25.8,
                27.74
            ],
            "text": " So if I go back to the code, what did I say?"
        },
        {
            "timestamp": [
                28.24,
                29.98
            ],
            "text": " We will be going till square."
        },
        {
            "timestamp": [
                0.0,
                6.0
            ],
            "text": " root of n right we'll be going to square root of we know this is a factor and we need a list"
        },
        {
            "timestamp": [
                6.0,
                14.48
            ],
            "text": " now so let's take a list so this is our list vector and we know ls dot push back of i a push back"
        },
        {
            "timestamp": [
                14.48,
                21.04
            ],
            "text": " i and we know the other factor is n by i if this is not equal to i that's the other factor again"
        },
        {
            "timestamp": [
                21.04,
                26.0
            ],
            "text": " we'll say list can you store the other factor and the other factor is n by i once you have"
        },
        {
            "timestamp": [
                26.0,
                29.98
            ],
            "text": " stored everything can you go ahead and say over here sort"
        },
        {
            "timestamp": [
                0.0,
                3.16
            ],
            "text": " LS dot begin, LS dot in."
        },
        {
            "timestamp": [
                3.96,
                6.56
            ],
            "text": " Once you have done this, just need to print it."
        },
        {
            "timestamp": [
                7.08,
                7.92
            ],
            "text": " You know how to print it?"
        },
        {
            "timestamp": [
                8.44,
                9.5
            ],
            "text": " This is how you print the list."
        },
        {
            "timestamp": [
                10.84,
                12.32
            ],
            "text": " C++ STL video guys."
        },
        {
            "timestamp": [
                13.54,
                18.22
            ],
            "text": " So I'll just iterate on the list and I'll print the list with space."
        },
        {
            "timestamp": [
                19.1,
                20.24
            ],
            "text": " So all of them are correct."
        },
        {
            "timestamp": [
                20.74,
                23.36
            ],
            "text": " Now go ahead and print and it will be correct."
        },
        {
            "timestamp": [
                23.74,
                24.64
            ],
            "text": " Why did I sort it?"
        },
        {
            "timestamp": [
                24.7,
                27.74
            ],
            "text": " Because they wanted us to print everything in the sorted order."
        },
        {
            "timestamp": [
                28.1,
                29.4
            ],
            "text": " It's very important to sort the list."
        },
        {
            "timestamp": [
                0.0,
                3.14
            ],
            "text": " I talk about the time complexity, what will be the time complexity?"
        },
        {
            "timestamp": [
                3.54,
                8.02
            ],
            "text": " Something before discussing the time complexity, you're writing I less than equal to square root of"
        },
        {
            "timestamp": [
                8.02,
                8.16
            ],
            "text": " n."
        },
        {
            "timestamp": [
                8.74,
                14.16
            ],
            "text": " Instead of this, because square root is a function and every time the function will be called"
        },
        {
            "timestamp": [
                14.16,
                17.96
            ],
            "text": " because square root is a mathematical function in C plus plus ST."
        },
        {
            "timestamp": [
                17.96,
                21.32
            ],
            "text": " This will be called every time, which will take time itself."
        },
        {
            "timestamp": [
                21.76,
                26.48
            ],
            "text": " Instead of writing this, you can actually write I into I lesser than equal to 1."
        },
        {
            "timestamp": [
                0.0,
                7.58
            ],
            "text": " It will be like when I reach a 6, it will be like 6 into 6 less than equal to 36."
        },
        {
            "timestamp": [
                7.88,
                8.54
            ],
            "text": " It will work."
        },
        {
            "timestamp": [
                8.94,
                14.5
            ],
            "text": " The moment it goes to 7, 7 into 7 is not equal to 36."
        },
        {
            "timestamp": [
                14.92,
                16.04
            ],
            "text": " So this will be false."
        },
        {
            "timestamp": [
                16.62,
                20.4
            ],
            "text": " So this is the other way of writing for the square root."
        },
        {
            "timestamp": [
                20.66,
                21.58
            ],
            "text": " This is what you can write."
        },
        {
            "timestamp": [
                21.7,
                27.0
            ],
            "text": " So can I say this loop is running for Biggo of square root of n times?"
        },
        {
            "timestamp": [
                27.12,
                27.7
            ],
            "text": " Can I say this?"
        },
        {
            "timestamp": [
                0.0,
                3.94
            ],
            "text": " that this loop is running for, we go off square root of time."
        },
        {
            "timestamp": [
                4.5,
                9.32
            ],
            "text": " And then the number of factors, whatever is the number of factors, you're sorting it."
        },
        {
            "timestamp": [
                9.76,
                12.8
            ],
            "text": " The internal sorting function takes n log in."
        },
        {
            "timestamp": [
                13.34,
                15.06
            ],
            "text": " What is the internal sorting function taking?"
        },
        {
            "timestamp": [
                15.66,
                17.24
            ],
            "text": " N log in, what is N?"
        },
        {
            "timestamp": [
                18.58,
                19.92
            ],
            "text": " N is the number of factors?"
        },
        {
            "timestamp": [
                20.32,
                21.46
            ],
            "text": " N is the number of factors."
        },
        {
            "timestamp": [
                22.36,
                22.52
            ],
            "text": " Right?"
        },
        {
            "timestamp": [
                23.22,
                25.56
            ],
            "text": " So can I say N is the number of factors?"
        },
        {
            "timestamp": [
                25.68,
                26.96
            ],
            "text": " N is not the original N."
        },
        {
            "timestamp": [
                27.4,
                28.44
            ],
            "text": " It is the number of factors."
        },
        {
            "timestamp": [
                0.0,
                3.14
            ],
            "text": " and then you're going ahead and printing it."
        },
        {
            "timestamp": [
                3.54,
                6.42
            ],
            "text": " So you're again taking a number of factors time to print it."
        },
        {
            "timestamp": [
                6.86,
                7.74
            ],
            "text": " Whatever is the number of time?"
        },
        {
            "timestamp": [
                8.22,
                12.74
            ],
            "text": " So the overall time complexity in this case is we go of square root of 1."
        },
        {
            "timestamp": [
                13.64,
                18.1
            ],
            "text": " Plus we go of number of factors into log of number of factors."
        },
        {
            "timestamp": [
                18.1,
                23.18
            ],
            "text": " So number of factors into log off,"
        },
        {
            "timestamp": [
                23.78,
                29.22
            ],
            "text": " provided properly, number of factors."
        },
        {
            "timestamp": [
                0.0,
                6.66
            ],
            "text": " got it quite simple and then plus this so big of this plus big of this plus big of this"
        },
        {
            "timestamp": [
                6.66,
                12.04
            ],
            "text": " is the time complexity but the motive was to teach you that you're gonna also find factors"
        },
        {
            "timestamp": [
                12.04,
                19.32
            ],
            "text": " in be go of square root of n got it i can say i've also done print all divisors in both the ways"
        },
        {
            "timestamp": [
                19.32,
                25.2
            ],
            "text": " now what is the next question it states check for prime so what is the definition of a prime"
        },
        {
            "timestamp": [
                0.0,
                6.32
            ],
            "text": " number a lot of you will say a number that is divisible by one and itself this is a wrong"
        },
        {
            "timestamp": [
                6.32,
                12.24
            ],
            "text": " definition why because according to this definition one is a prime number because one is"
        },
        {
            "timestamp": [
                12.24,
                16.96
            ],
            "text": " divisible by one and one is divisible by itself which is one it's a wrong definition"
        },
        {
            "timestamp": [
                17.6,
                23.44
            ],
            "text": " instead of this the definition that you should always keep in mind is a number that has"
        },
        {
            "timestamp": [
                23.44,
                29.98
            ],
            "text": " exactly two factors one and itself that's"
        },
        {
            "timestamp": [
                0.0,
                7.04
            ],
            "text": " a better definition one and itself a number that has two factors which is one and itself so if you"
        },
        {
            "timestamp": [
                7.04,
                16.0
            ],
            "text": " remember we're just now computed factors so if you're given a number something like 11 can i say"
        },
        {
            "timestamp": [
                16.0,
                21.92
            ],
            "text": " 11 has a factor of 1 and 11 itself any other number doesn't divide 11 so 11 is a prime number"
        },
        {
            "timestamp": [
                21.92,
                29.92
            ],
            "text": " if i say 13 30 is a prime number because 1 and 13 divides it whereas a 5 5 is a prime number because 1 and 5 divides it"
        },
        {
            "timestamp": [
                0.0,
                4.08
            ],
            "text": " If I say 4, 4 is not a prime number. Why?"
        },
        {
            "timestamp": [
                4.58,
                6.12
            ],
            "text": " Because it is divisible by 1."
        },
        {
            "timestamp": [
                6.62,
                7.92
            ],
            "text": " It is divisible by 2."
        },
        {
            "timestamp": [
                8.24,
                10.08
            ],
            "text": " It is also divisible by 4."
        },
        {
            "timestamp": [
                10.34,
                11.32
            ],
            "text": " So there are three factors."
        },
        {
            "timestamp": [
                11.82,
                13.06
            ],
            "text": " So 4 is not a prime number."
        },
        {
            "timestamp": [
                13.5,
                14.16
            ],
            "text": " We take 8."
        },
        {
            "timestamp": [
                14.46,
                15.38
            ],
            "text": " It is not a prime number."
        },
        {
            "timestamp": [
                15.5,
                15.66
            ],
            "text": " Why?"
        },
        {
            "timestamp": [
                16.22,
                17.98
            ],
            "text": " Divisible by 1, 2, 4, 8."
        },
        {
            "timestamp": [
                18.3,
                19.24
            ],
            "text": " So not a prime number."
        },
        {
            "timestamp": [
                19.6,
                25.0
            ],
            "text": " Something like 17 is a prime number because divisible by 1 and 17."
        },
        {
            "timestamp": [
                25.0,
                28.94
            ],
            "text": " So what is the first, the brute force?"
        },
        {
            "timestamp": [
                0.0,
                1.82
            ],
            "text": " What is the definition of brute force?"
        },
        {
            "timestamp": [
                2.36,
                7.8
            ],
            "text": " The algorithm which is the first algorithm or the initial algorithm that comes to your mind."
        },
        {
            "timestamp": [
                8.0,
                8.08
            ],
            "text": " Okay."
        },
        {
            "timestamp": [
                8.5,
                15.34
            ],
            "text": " So can I see the simplest way to check is I will do one thing."
        },
        {
            "timestamp": [
                15.68,
                17.5
            ],
            "text": " I'll keep a counter equal to zero."
        },
        {
            "timestamp": [
                18.24,
                21.42
            ],
            "text": " And I know it exactly has two factors."
        },
        {
            "timestamp": [
                21.9,
                28.56
            ],
            "text": " So I'll run a loop from one and I'll go on till N and I'll say I plus plus and I'll say hey listen."
        },
        {
            "timestamp": [
                0.0,
                6.96
            ],
            "text": " if it is a factor, it will be completely divisible by i, hence it will leave a remainder"
        },
        {
            "timestamp": [
                6.96,
                10.5
            ],
            "text": " 0 and I'll do a counter plus plus."
        },
        {
            "timestamp": [
                11.02,
                17.22
            ],
            "text": " And can I say at the end of the day, if the counter turns out to be 2, then I'll say it's"
        },
        {
            "timestamp": [
                17.22,
                20.46
            ],
            "text": " a prime number or else it's not a prime number."
        },
        {
            "timestamp": [
                20.92,
                25.9
            ],
            "text": " So can I say this is the extreme brute force approach?"
        },
        {
            "timestamp": [
                26.4,
                29.98
            ],
            "text": " And if I write the extreme brute force approach, what will be the time?"
        },
        {
            "timestamp": [
                0.0,
                2.46
            ],
            "text": " complexity of the extreme brute force approach."
        },
        {
            "timestamp": [
                3.06,
                7.24
            ],
            "text": " Can I say I'm running a loop n and these are unit operations so I can ignore?"
        },
        {
            "timestamp": [
                7.66,
                14.04
            ],
            "text": " So can I say the time complexity will be bego of n because I'm running a l loop to check for every I,"
        },
        {
            "timestamp": [
                14.4,
                20.08
            ],
            "text": " which can be a factor and then I'm checking it and there is and after that there are conditional checks"
        },
        {
            "timestamp": [
                20.08,
                22.2
            ],
            "text": " which are unit operations can be avoided."
        },
        {
            "timestamp": [
                22.74,
                27.1
            ],
            "text": " So this is bgo of n and we know that factors are involved."
        },
        {
            "timestamp": [
                27.6,
                29.9
            ],
            "text": " In the previous problem, we did learn."
        },
        {
            "timestamp": [
                0.0,
                3.24
            ],
            "text": " that all the factors can be found in square root of n."
        },
        {
            "timestamp": [
                3.6,
                3.9
            ],
            "text": " Why?"
        },
        {
            "timestamp": [
                4.34,
                7.76
            ],
            "text": " Because if you remember 36, 36 had a factor 1."
        },
        {
            "timestamp": [
                8.2,
                11.96
            ],
            "text": " The corresponding factor like the corresponding other factor was 36."
        },
        {
            "timestamp": [
                12.6,
                18.08
            ],
            "text": " 2's 18, 3 is 12, 4s, 9 and 66."
        },
        {
            "timestamp": [
                18.58,
                21.7
            ],
            "text": " Even if you checked till square root of n,"
        },
        {
            "timestamp": [
                22.4,
                24.52
            ],
            "text": " you could actually count all the factors."
        },
        {
            "timestamp": [
                24.52,
                29.98
            ],
            "text": " And all the factors were 1, 2, 3, 4, 6, 9, 12, 8,000, 8,000."
        },
        {
            "timestamp": [
                0.0,
                2.78
            ],
            "text": " in 36, you can count all the factors."
        },
        {
            "timestamp": [
                3.4,
                6.68
            ],
            "text": " Even if you loop till square root of n."
        },
        {
            "timestamp": [
                7.26,
                9.54
            ],
            "text": " So why are you looping till we go of n?"
        },
        {
            "timestamp": [
                10.1,
                12.54
            ],
            "text": " Kindly look till square root of n."
        },
        {
            "timestamp": [
                12.96,
                14.7
            ],
            "text": " So what do you'll do is you'll say I equal to 1."
        },
        {
            "timestamp": [
                15.3,
                20.84
            ],
            "text": " I into I lesser than n, I've already taught you this and count a equal to 0."
        },
        {
            "timestamp": [
                21.46,
                27.92
            ],
            "text": " And you'll say if N modulo I is equal to 0, that is definitely a factor."
        },
        {
            "timestamp": [
                0.0,
                4.22
            ],
            "text": " and at the same time, the other factor has to be different."
        },
        {
            "timestamp": [
                4.72,
                8.62
            ],
            "text": " And if the other factor is different, then it will also be counted."
        },
        {
            "timestamp": [
                9.58,
                11.76
            ],
            "text": " And then you can have a seam check."
        },
        {
            "timestamp": [
                11.88,
                17.66
            ],
            "text": " If counter is equal to equal to 2, prime, else not a prime number."
        },
        {
            "timestamp": [
                18.1,
                19.06
            ],
            "text": " As simple as that."
        },
        {
            "timestamp": [
                19.88,
                26.56
            ],
            "text": " And if I talk about the time complexity, this loop ends up running for Bgo of square root of n."
        },
        {
            "timestamp": [
                27.06,
                29.94
            ],
            "text": " So if someone is coming up and asking you, how do you check?"
        },
        {
            "timestamp": [
                0.0,
                3.06
            ],
            "text": " for a prime number, you say I know the square root method."
        },
        {
            "timestamp": [
                3.06,
                5.04
            ],
            "text": " Because I know the observation."
        },
        {
            "timestamp": [
                5.04,
                8.32
            ],
            "text": " Every factor there is the other corresponding number"
        },
        {
            "timestamp": [
                8.32,
                12.0
            ],
            "text": " with which it has to get multiplied in order to get the number."
        },
        {
            "timestamp": [
                12.0,
                14.42
            ],
            "text": " Thereby I can just go up to square root of n."
        },
        {
            "timestamp": [
                14.42,
                15.72
            ],
            "text": " Nothing beyond it."
        },
        {
            "timestamp": [
                15.72,
                19.12
            ],
            "text": " Because still square root of n, I'll get all the factors."
        },
        {
            "timestamp": [
                19.12,
                21.96
            ],
            "text": " So this is the code that I did write in the iPad."
        },
        {
            "timestamp": [
                21.96,
                23.82
            ],
            "text": " So I'll know quickly go ahead and submit this"
        },
        {
            "timestamp": [
                23.82,
                25.6
            ],
            "text": " and see if it is working fine."
        },
        {
            "timestamp": [
                25.6,
                26.94
            ],
            "text": " It is indeed working fine."
        },
        {
            "timestamp": [
                28.48,
                29.98
            ],
            "text": " So we have completed the check"
        },
        {
            "timestamp": [
                0.0,
                5.7
            ],
            "text": " for prime. So apparently you have completed everything and the GCD or the HCF is left."
        },
        {
            "timestamp": [
                5.98,
                10.02
            ],
            "text": " So let's go across and learn the GCD or HCF and then come back and take it over."
        },
        {
            "timestamp": [
                10.44,
                14.1
            ],
            "text": " So what do you mean by GCD or HCF? It's very simple."
        },
        {
            "timestamp": [
                14.56,
                19.72
            ],
            "text": " Greatest common divisor or highest common factor. Let me give you an example."
        },
        {
            "timestamp": [
                20.34,
                29.98
            ],
            "text": " If I give you two numbers, N1 equal to 9 and N2 equal to 12, so you need to find the highest common factor or greatest common divisor that actually divides."
        },
        {
            "timestamp": [
                0.0,
                10.32
            ],
            "text": " and that divides 9 and 12 so if I write down all the factors of 9 it is 1 3 and 9"
        },
        {
            "timestamp": [
                10.32,
                22.32
            ],
            "text": " if I write down all the factors of 12 it is 1 2 6 and 12 even 3 4 that these are all"
        },
        {
            "timestamp": [
                22.32,
                28.44
            ],
            "text": " the factors of 12 so if I ask you the common factors the common factors if I go ahead and"
        },
        {
            "timestamp": [
                28.44,
                29.98
            ],
            "text": " mark it is 1"
        },
        {
            "timestamp": [
                0.0,
                3.14
            ],
            "text": " 1, it is 3, 3."
        },
        {
            "timestamp": [
                3.54,
                4.76
            ],
            "text": " So there are two common factors."
        },
        {
            "timestamp": [
                5.22,
                8.3
            ],
            "text": " Out of these two common factors, which is the highest one, 3."
        },
        {
            "timestamp": [
                8.8,
                18.42
            ],
            "text": " So I can say the GCD of 9.12 is 3 because 3 is the largest number that divides 9 and 12 both."
        },
        {
            "timestamp": [
                18.86,
                23.46
            ],
            "text": " If I ask you the GCD of 11 and 13, what will be it?"
        },
        {
            "timestamp": [
                23.86,
                24.9
            ],
            "text": " It will be 1."
        },
        {
            "timestamp": [
                25.32,
                29.42
            ],
            "text": " Because if you try to write down all the factors of 11, it's going to be 1 and 11."
        },
        {
            "timestamp": [
                0.0,
                2.12
            ],
            "text": " All the factors of 13, 1 and 13."
        },
        {
            "timestamp": [
                2.56,
                6.76
            ],
            "text": " So the common one is just one and that is the GCD."
        },
        {
            "timestamp": [
                7.18,
                12.54
            ],
            "text": " So there will always be a GCD because one is a number that divides every other number."
        },
        {
            "timestamp": [
                13.0,
                18.04
            ],
            "text": " So for every given two numbers, there will always be a GCD or HCF."
        },
        {
            "timestamp": [
                18.04,
                25.04
            ],
            "text": " If I ask you, what is the GCD of 20, 30 or rather 20, 40?"
        },
        {
            "timestamp": [
                25.84,
                27.42
            ],
            "text": " What is the GCD of 20?40?"
        },
        {
            "timestamp": [
                28.08,
                29.98
            ],
            "text": " Because for 20, 20, 20 is a factor."
        },
        {
            "timestamp": [
                0.0,
                2.48
            ],
            "text": " And for 40, 20 is also a factor."
        },
        {
            "timestamp": [
                2.94,
                4.26
            ],
            "text": " So that's why 20."
        },
        {
            "timestamp": [
                4.7,
                10.22
            ],
            "text": " So for two given numbers, one of them can also be a GCD of those two given numbers."
        },
        {
            "timestamp": [
                10.64,
                13.22
            ],
            "text": " So that is what is the definition of GCD."
        },
        {
            "timestamp": [
                24.82,
                29.98
            ],
            "text": " So all of you know how to find factors of two given numbers."
        },
        {
            "timestamp": [
                0.0,
                29.54
            ],
            "text": " you give in n1 and you're given n2 so in the last two problems you have learned how to find factors so imagine it's like n1 is 9 and n2 is 12 so can i say if i loop from 1 to 12 and for every number i'll check if they're dividing both does 1 divide both yes one as of now is the largest factor"
        },
        {
            "timestamp": [
                0.0,
                1.06
            ],
            "text": " Does 2 divide both?"
        },
        {
            "timestamp": [
                1.26,
                1.46
            ],
            "text": " No."
        },
        {
            "timestamp": [
                2.06,
                3.42
            ],
            "text": " Does 3 divide both?"
        },
        {
            "timestamp": [
                3.76,
                4.08
            ],
            "text": " Yes."
        },
        {
            "timestamp": [
                4.6,
                5.4
            ],
            "text": " So 3 is the largest."
        },
        {
            "timestamp": [
                5.94,
                10.6
            ],
            "text": " If I can check every number and if every number divides both of them,"
        },
        {
            "timestamp": [
                10.98,
                12.6
            ],
            "text": " if a number divides both of them,"
        },
        {
            "timestamp": [
                13.1,
                15.78
            ],
            "text": " I just replace that with my GCD's answer."
        },
        {
            "timestamp": [
                15.78,
                22.18
            ],
            "text": " And the largest number that I get, that divides both of them will be my GCD."
        },
        {
            "timestamp": [
                22.68,
                26.56
            ],
            "text": " If I try to write it, can I write this as I equal to 1?"
        },
        {
            "timestamp": [
                27.44,
                28.98
            ],
            "text": " Maybe I will loop till N1?"
        },
        {
            "timestamp": [
                0.0,
                12.18
            ],
            "text": " maybe i plus plus and i'll say if n1 modulo i equal to equal to zero and n2 modulo i equal to"
        },
        {
            "timestamp": [
                12.18,
                18.46
            ],
            "text": " 0 and i'll say as of now i know one thing for sure any given two numbers any given two"
        },
        {
            "timestamp": [
                18.46,
                28.04
            ],
            "text": " numbers will always have a gcd of 1 so gcd will be replaced by i can i see this because i is"
        },
        {
            "timestamp": [
                0.0,
                0.82
            ],
            "text": " starting from 1."
        },
        {
            "timestamp": [
                1.32,
                5.32
            ],
            "text": " So it goes from 1, then it goes to 2, then goes to 3."
        },
        {
            "timestamp": [
                5.78,
                10.2
            ],
            "text": " So whichever number divides both of them, it just keeps on getting replaced."
        },
        {
            "timestamp": [
                10.2,
                18.74
            ],
            "text": " The last number, which will be stored in GCD, will definitely be the largest because I is moving in the increasing fashion."
        },
        {
            "timestamp": [
                19.04,
                19.52
            ],
            "text": " Very simple."
        },
        {
            "timestamp": [
                20.06,
                29.7
            ],
            "text": " Now, you might ask me, but Striver, what if N was given as 12 and N2 was given as 9?"
        },
        {
            "timestamp": [
                0.0,
                5.64
            ],
            "text": " then the fall loop would have been running for 12 times."
        },
        {
            "timestamp": [
                6.24,
                12.58
            ],
            "text": " But I know one thing for sure that if IS 10, the 10 will not divide 9."
        },
        {
            "timestamp": [
                13.08,
                14.54
            ],
            "text": " There is no point in checking."
        },
        {
            "timestamp": [
                15.16,
                24.56
            ],
            "text": " So can I say instead of running till N1, I can actually run it for something like minimum of N1."
        },
        {
            "timestamp": [
                24.96,
                29.98
            ],
            "text": " Because I know if I run till minimum of N1 comma N2, like now,"
        },
        {
            "timestamp": [
                0.0,
                3.0
            ],
            "text": " If I run till 9, that will suffice."
        },
        {
            "timestamp": [
                3.0,
                6.0
            ],
            "text": " Running 10, 11 doesn't make sense."
        },
        {
            "timestamp": [
                6.0,
                10.0
            ],
            "text": " For example, if the number was 20 and 40,"
        },
        {
            "timestamp": [
                10.0,
                13.0
            ],
            "text": " if I run until 20, that will work."
        },
        {
            "timestamp": [
                13.0,
                16.0
            ],
            "text": " Because 20 is the largest factor I can have."
        },
        {
            "timestamp": [
                16.0,
                19.0
            ],
            "text": " Running it for 21, 22 will not make sense."
        },
        {
            "timestamp": [
                19.0,
                23.0
            ],
            "text": " So can I say I can run the loop till minimum of N1 comment?"
        },
        {
            "timestamp": [
                23.0,
                24.0
            ],
            "text": " I can?"
        },
        {
            "timestamp": [
                24.0,
                28.0
            ],
            "text": " Thereby, can I say the time complexity will be"
        },
        {
            "timestamp": [
                0.0,
                4.16
            ],
            "text": " We go of minimum of N1 comma N2, whichever is minimum."
        },
        {
            "timestamp": [
                4.6,
                5.5
            ],
            "text": " Till that I'll run the loop."
        },
        {
            "timestamp": [
                5.78,
                9.38
            ],
            "text": " So thereby the time complexity is minimum of N1 comma N2."
        },
        {
            "timestamp": [
                9.72,
                11.22
            ],
            "text": " Now you might have questions in your head."
        },
        {
            "timestamp": [
                11.76,
                15.48
            ],
            "text": " But Striver, we are trying to find highest."
        },
        {
            "timestamp": [
                16.7,
                18.48
            ],
            "text": " And over here, what are you doing?"
        },
        {
            "timestamp": [
                18.92,
                22.38
            ],
            "text": " You're going from 1, 2, 3, 4 and you're checking everyone."
        },
        {
            "timestamp": [
                23.06,
                28.88
            ],
            "text": " But what if N1 is 20, N2 is 40?"
        },
        {
            "timestamp": [
                0.0,
                1.46
            ],
            "text": " and I do the other way."
        },
        {
            "timestamp": [
                1.82,
                7.3
            ],
            "text": " Yes, I do the other way and I say, I'll run it from minimum of N1 comma N2,"
        },
        {
            "timestamp": [
                8.5,
                17.04
            ],
            "text": " I greater than equal to 1, I minus minus, and I'll say if N1 modulo I equal to 0"
        },
        {
            "timestamp": [
                17.04,
                28.56
            ],
            "text": " and N2 module I equal to equal to 0, I will print that as my GCD and I'll break and I'll break."
        },
        {
            "timestamp": [
                0.0,
                2.0
            ],
            "text": " and you know what is the task of break"
        },
        {
            "timestamp": [
                2.0,
                4.3
            ],
            "text": " it always breaks out from the outer loop"
        },
        {
            "timestamp": [
                4.3,
                6.88
            ],
            "text": " not this is a conditional statement"
        },
        {
            "timestamp": [
                6.88,
                7.72
            ],
            "text": " this is not a loop"
        },
        {
            "timestamp": [
                7.72,
                9.94
            ],
            "text": " for this break which is the"
        },
        {
            "timestamp": [
                9.94,
                12.28
            ],
            "text": " loop that is outside this break this one"
        },
        {
            "timestamp": [
                12.28,
                13.62
            ],
            "text": " it will break out from this"
        },
        {
            "timestamp": [
                13.62,
                14.76
            ],
            "text": " how does it work"
        },
        {
            "timestamp": [
                14.76,
                17.18
            ],
            "text": " the minimum of 20 40 is"
        },
        {
            "timestamp": [
                17.18,
                19.38
            ],
            "text": " 20 so 20"
        },
        {
            "timestamp": [
                19.38,
                21.82
            ],
            "text": " 20 modulo 20"
        },
        {
            "timestamp": [
                21.82,
                23.54
            ],
            "text": " equal to 0 yes"
        },
        {
            "timestamp": [
                23.54,
                26.64
            ],
            "text": " 40 modular 20 equal to 0 yes"
        },
        {
            "timestamp": [
                26.64,
                29.34
            ],
            "text": " print GCDS 20 yes"
        },
        {
            "timestamp": [
                0.0,
                7.66
            ],
            "text": " break. So the program terminates. In this way you will say in this way it will have a better"
        },
        {
            "timestamp": [
                7.66,
                13.66
            ],
            "text": " complexity because the moment you are getting someone from behind it breaks out. You might give"
        },
        {
            "timestamp": [
                13.66,
                20.68
            ],
            "text": " me this. Yeah definitely this might turn out to be a better one for a lot of cases. But still"
        },
        {
            "timestamp": [
                20.68,
                29.9
            ],
            "text": " the worst case will be minimum of n1 comma n2. Imagine I give you two numbers. N1 equal to 11. N2. N2"
        },
        {
            "timestamp": [
                0.0,
                6.78
            ],
            "text": " to 13. In this case, what will happen? For 11 and 13, the highest common factor is 1."
        },
        {
            "timestamp": [
                7.42,
                15.34
            ],
            "text": " It will start from 11, 10, 9, but will not find anyone till 1. So, it will eventually loop from 11 to 1."
        },
        {
            "timestamp": [
                15.84,
                23.74
            ],
            "text": " So no matter what you do, the time complexity will be still this. Because if both the numbers of GCD as 1,"
        },
        {
            "timestamp": [
                23.74,
                29.94
            ],
            "text": " it ends up running completely. The loop ends up running completely. And you know when you determine the"
        },
        {
            "timestamp": [
                0.0,
                5.44
            ],
            "text": " time complexity, taught you in the time complexity lecture, you always take worst case."
        },
        {
            "timestamp": [
                5.44,
                7.44
            ],
            "text": " You always take worst case."
        },
        {
            "timestamp": [
                7.44,
                10.32
            ],
            "text": " The worst case is when you run it till one."
        },
        {
            "timestamp": [
                11.12,
                15.36
            ],
            "text": " We saw the previous method was a brute force method and was taking linear time complexity."
        },
        {
            "timestamp": [
                15.36,
                22.24
            ],
            "text": " Now there is an algorithm known as equiloidian algorithm which is going to take much, much lesser time."
        },
        {
            "timestamp": [
                22.24,
                23.84
            ],
            "text": " So let's learn about it."
        },
        {
            "timestamp": [
                23.84,
                26.08
            ],
            "text": " So what is equiloidian algorithm?"
        },
        {
            "timestamp": [
                26.08,
                29.92
            ],
            "text": " It states if you're given two numbers n1 comma n2,"
        },
        {
            "timestamp": [
                0.0,
                12.62
            ],
            "text": " The GCD of N1 comma N2, whatever is the GCD of N1 comma N2, that's equivalent to the GCD of N1 minus N2"
        },
        {
            "timestamp": [
                12.62,
                17.92
            ],
            "text": " where where N1 is greater than N2."
        },
        {
            "timestamp": [
                18.66,
                27.16
            ],
            "text": " Usually in books you will find them written as GCD of A comma B is equal to GCD of A minus B"
        },
        {
            "timestamp": [
                0.0,
                2.22
            ],
            "text": " comma B where A is greater than B."
        },
        {
            "timestamp": [
                2.68,
                3.92
            ],
            "text": " This is what the E."
        },
        {
            "timestamp": [
                3.92,
                5.48
            ],
            "text": " Ecculloidian algorithm states."
        },
        {
            "timestamp": [
                6.04,
                7.88
            ],
            "text": " If you want a mathematical proof of it,"
        },
        {
            "timestamp": [
                8.32,
                9.64
            ],
            "text": " you can definitely"
        },
        {
            "timestamp": [
                9.64,
                12.12
            ],
            "text": " Google search. There's a huge"
        },
        {
            "timestamp": [
                12.12,
                13.94
            ],
            "text": " mathematical proof to it. Again, we"
        },
        {
            "timestamp": [
                13.94,
                15.9
            ],
            "text": " will not go deep into the mathematical proof"
        },
        {
            "timestamp": [
                15.9,
                17.9
            ],
            "text": " because it is not required"
        },
        {
            "timestamp": [
                17.9,
                19.48
            ],
            "text": " in programming world."
        },
        {
            "timestamp": [
                19.82,
                21.5
            ],
            "text": " You just need this concept."
        },
        {
            "timestamp": [
                21.68,
                23.9
            ],
            "text": " So just have the concept. Now, if I"
        },
        {
            "timestamp": [
                23.9,
                25.86
            ],
            "text": " try to prove this with induction, it's very"
        },
        {
            "timestamp": [
                25.86,
                27.38
            ],
            "text": " simple. If I"
        },
        {
            "timestamp": [
                27.38,
                29.66
            ],
            "text": " give you two numbers, imagine"
        },
        {
            "timestamp": [
                0.0,
                1.4
            ],
            "text": " 15 and 20."
        },
        {
            "timestamp": [
                2.04,
                5.8
            ],
            "text": " So it basically states the greater number and the smaller number."
        },
        {
            "timestamp": [
                6.16,
                7.74
            ],
            "text": " What is the GCD of 20 comma 5?"
        },
        {
            "timestamp": [
                8.3,
                11.2
            ],
            "text": " We know the GCD of 20.15 is 5."
        },
        {
            "timestamp": [
                11.8,
                18.5
            ],
            "text": " So it states the GCD of 20.15, the greater number 20 and the smaller number 15 is equal to,"
        },
        {
            "timestamp": [
                19.5,
                21.1
            ],
            "text": " it states greater minus smaller."
        },
        {
            "timestamp": [
                21.54,
                22.6
            ],
            "text": " 20 minus 15."
        },
        {
            "timestamp": [
                23.5,
                25.54
            ],
            "text": " 5 comma the smaller number 15."
        },
        {
            "timestamp": [
                25.94,
                27.08
            ],
            "text": " So what is the GCD of 5?"
        },
        {
            "timestamp": [
                27.54,
                28.84
            ],
            "text": " That is also 5."
        },
        {
            "timestamp": [
                0.0,
                3.02
            ],
            "text": " So again, by induction also you can prove it."
        },
        {
            "timestamp": [
                3.36,
                6.8
            ],
            "text": " You can take any two numbers and you'll be able to prove that they are same."
        },
        {
            "timestamp": [
                7.56,
                13.8
            ],
            "text": " So I can say that the GCD of 20.15 is equivalent to the GCD of 5.5."
        },
        {
            "timestamp": [
                14.92,
                21.34
            ],
            "text": " Now, you applied the Echoloidion on the first two numbers and whatever you get,"
        },
        {
            "timestamp": [
                21.8,
                23.94
            ],
            "text": " that will always be a truncated number."
        },
        {
            "timestamp": [
                24.36,
                26.46
            ],
            "text": " You saw 20 getting truncated to 5."
        },
        {
            "timestamp": [
                0.0,
                21.56
            ],
            "text": " again you will apply equilodeon to this if we try to apply equilodeon to 5.15 it has to be the greater number at first so apparently you have to apply equilordion to 15.5 because 15 is the greater number right so what do you do is you say okay let's apply equalardion to 15 comma 5."
        },
        {
            "timestamp": [
                22.06,
                29.9
            ],
            "text": " They'll be like GCD of 15 minus 5 10.5 again you can apply equiloidian to 10.5."
        },
        {
            "timestamp": [
                0.0,
                5.68
            ],
            "text": " If you apply Echlorid into 10.5, it will be greater is 10, 10 minus 5 is 5."
        },
        {
            "timestamp": [
                6.18,
                6.82
            ],
            "text": " 5.5."
        },
        {
            "timestamp": [
                7.32,
                13.06
            ],
            "text": " Again, if you apply equiloid into 5.5, it will be both of them are same."
        },
        {
            "timestamp": [
                13.14,
                14.14
            ],
            "text": " Anyone can be at the front."
        },
        {
            "timestamp": [
                14.74,
                15.44
            ],
            "text": " 0.5."
        },
        {
            "timestamp": [
                15.86,
                18.44
            ],
            "text": " So 1 apparently becomes 0."
        },
        {
            "timestamp": [
                19.02,
                21.26
            ],
            "text": " The moment one of the numbers become 0."
        },
        {
            "timestamp": [
                21.76,
                24.4
            ],
            "text": " The other number is actually a GCD."
        },
        {
            "timestamp": [
                25.62,
                26.74
            ],
            "text": " It is actually a GCD."
        },
        {
            "timestamp": [
                27.26,
                29.8
            ],
            "text": " So the GCD of 20.15 is this."
        },
        {
            "timestamp": [
                0.0,
                4.24
            ],
            "text": " What do you do is you take two numbers, apply equal idea, get it smaller, apply"
        },
        {
            "timestamp": [
                4.24,
                8.24
            ],
            "text": " equal idea, get it smaller, get it smaller, till one of them is zero."
        },
        {
            "timestamp": [
                8.24,
                11.44
            ],
            "text": " If one of them is zero, the other is zero."
        },
        {
            "timestamp": [
                11.44,
                13.68
            ],
            "text": " So the algorithm is quite simple."
        },
        {
            "timestamp": [
                13.68,
                21.92
            ],
            "text": " Start with A comma B, keep on truncating, keep on truncating with A minus B comma B and keep on doing"
        },
        {
            "timestamp": [
                21.92,
                26.16
            ],
            "text": " till one of them, the greater number becomes zero."
        },
        {
            "timestamp": [
                26.16,
                27.2
            ],
            "text": " That's simple as well."
        },
        {
            "timestamp": [
                27.2,
                28.64
            ],
            "text": " But there's a catch."
        },
        {
            "timestamp": [
                0.0,
                2.56
            ],
            "text": " this might end up taking a lot more time."
        },
        {
            "timestamp": [
                3.28,
                9.04
            ],
            "text": " Imagine I give you a number like A equal to 52 and B equal to 10."
        },
        {
            "timestamp": [
                9.68,
                11.84
            ],
            "text": " So it'll be like, what will you do?"
        },
        {
            "timestamp": [
                11.84,
                20.56
            ],
            "text": " You will say GCD of 52.10 truncated to GCD 402.10, truncated to GCD 32.10."
        },
        {
            "timestamp": [
                20.56,
                23.28
            ],
            "text": " Truncated to GCD 32.10."
        },
        {
            "timestamp": [
                23.28,
                26.32
            ],
            "text": " Truncated to GCD 22.2."
        },
        {
            "timestamp": [
                26.32,
                29.92
            ],
            "text": " Truncated to GCD 12.10."
        },
        {
            "timestamp": [
                0.0,
                7.64
            ],
            "text": " truncated to GCD 2.10 and then you again take the bigger number at first, 10.2,"
        },
        {
            "timestamp": [
                8.12,
                16.18
            ],
            "text": " and then you'll be again like truncated to 8.2, truncated to 6.2, 4.2, 2.2 and 2.2 and"
        },
        {
            "timestamp": [
                16.18,
                19.6
            ],
            "text": " ultimately, 2 is left because everything comes up."
        },
        {
            "timestamp": [
                20.04,
                22.64
            ],
            "text": " So, it's a lot of sticks. It's a lot of sticks."
        },
        {
            "timestamp": [
                23.0,
                26.22
            ],
            "text": " It might not improve the linear complexity by so much."
        },
        {
            "timestamp": [
                26.52,
                27.52
            ],
            "text": " But there's a catch over here."
        },
        {
            "timestamp": [
                0.0,
                8.44
            ],
            "text": " if it is 52 and it was 10 and you're reducing it with 10 every time and you ended up at a place"
        },
        {
            "timestamp": [
                8.44,
                16.24
            ],
            "text": " of 2.10 isn't it equivalent to saying you're dividing it by 10 and you're like 52 if you"
        },
        {
            "timestamp": [
                16.24,
                25.44
            ],
            "text": " divide it by 10 it's like 5 you did it 5 times 1 2 3 4 5 and you ended up having the remainder"
        },
        {
            "timestamp": [
                25.44,
                29.46
            ],
            "text": " because you are minus 10 minus 10 minus 10 till it is possible"
        },
        {
            "timestamp": [
                0.0,
                6.0
            ],
            "text": " It's equivalent to saying you subtract it till it was possible or till it is greater."
        },
        {
            "timestamp": [
                6.94,
                18.2
            ],
            "text": " Can I see instead of subtracting it five times, you could have directly gone from here to here by saying 52 Modulo 10.10."
        },
        {
            "timestamp": [
                19.24,
                19.98
            ],
            "text": " That's same."
        },
        {
            "timestamp": [
                20.82,
                21.34
            ],
            "text": " 2.10."
        },
        {
            "timestamp": [
                21.54,
                26.38
            ],
            "text": " That is same instead of subtracting 10, 5 times, directly get 2.2."
        },
        {
            "timestamp": [
                0.0,
                8.76
            ],
            "text": " even from 10 comma 2 to 0.2, you could have directly gone by saying 10 modulo 2 because that is what you did indirectly simple match."
        },
        {
            "timestamp": [
                9.42,
                19.74
            ],
            "text": " So can I see the algorithm in a better sense will be GCD of A comma B, but definitely A is greater than B is equal to A modulo B."
        },
        {
            "timestamp": [
                20.24,
                21.18
            ],
            "text": " That's a better one."
        },
        {
            "timestamp": [
                22.08,
                23.02
            ],
            "text": " And you go on doing it."
        },
        {
            "timestamp": [
                23.46,
                25.86
            ],
            "text": " Then it becomes zero as simple as that."
        },
        {
            "timestamp": [
                26.42,
                27.66
            ],
            "text": " You always take the greater number."
        },
        {
            "timestamp": [
                0.0,
                2.46
            ],
            "text": " So the logic is very simple."
        },
        {
            "timestamp": [
                3.36,
                4.2
            ],
            "text": " Forget about A and B."
        },
        {
            "timestamp": [
                4.6,
                5.54
            ],
            "text": " The logic is very simple."
        },
        {
            "timestamp": [
                6.38,
                7.22
            ],
            "text": " The greater,"
        },
        {
            "timestamp": [
                7.96,
                8.84
            ],
            "text": " modular is smaller."
        },
        {
            "timestamp": [
                9.78,
                10.42
            ],
            "text": " That's the logic."
        },
        {
            "timestamp": [
                10.98,
                11.6
            ],
            "text": " And they go on"
        },
        {
            "timestamp": [
                11.6,
                14.14
            ],
            "text": " till one of them is zero."
        },
        {
            "timestamp": [
                14.54,
                16.44
            ],
            "text": " And if one of them is zero, remember this."
        },
        {
            "timestamp": [
                17.04,
                19.8
            ],
            "text": " If one of them is zero,"
        },
        {
            "timestamp": [
                20.28,
                21.7
            ],
            "text": " the other is GCD."
        },
        {
            "timestamp": [
                22.3,
                23.32
            ],
            "text": " The other is GCD."
        },
        {
            "timestamp": [
                25.24,
                26.14
            ],
            "text": " As simple as this."
        },
        {
            "timestamp": [
                26.14,
                28.08
            ],
            "text": " If I try to code this up,"
        },
        {
            "timestamp": [
                28.52,
                29.5
            ],
            "text": " try to quote this up."
        },
        {
            "timestamp": [
                0.0,
                7.04
            ],
            "text": " you're given A, a given B, can I say you go on till both of them are greater, greater than zero?"
        },
        {
            "timestamp": [
                7.74,
                8.08
            ],
            "text": " Very simple."
        },
        {
            "timestamp": [
                9.0,
                11.16
            ],
            "text": " And I know one of them will be greater."
        },
        {
            "timestamp": [
                11.78,
                12.66
            ],
            "text": " Either A will be greater."
        },
        {
            "timestamp": [
                13.08,
                14.8
            ],
            "text": " In that case, I'll do A module B."
        },
        {
            "timestamp": [
                15.52,
                23.02
            ],
            "text": " Or else if B is greater, I'll do B module A instead of swapping changing because I did not want to get into swapping changing."
        },
        {
            "timestamp": [
                23.14,
                23.3
            ],
            "text": " Why?"
        },
        {
            "timestamp": [
                24.36,
                25.48
            ],
            "text": " Over here it was 2.10."
        },
        {
            "timestamp": [
                25.58,
                26.6
            ],
            "text": " So A was this, B was there."
        },
        {
            "timestamp": [
                27.1,
                28.38
            ],
            "text": " And you swapped it to this."
        },
        {
            "timestamp": [
                28.68,
                29.98
            ],
            "text": " I did not want to improve."
        },
        {
            "timestamp": [
                0.0,
                7.6
            ],
            "text": " implement that I just I knew now 10 will be modulated so what I did was I implemented it in such a way"
        },
        {
            "timestamp": [
                7.6,
                15.52
            ],
            "text": " stating if a is greater a will be modulated if b is greater we will be modulated and once this is over"
        },
        {
            "timestamp": [
                16.88,
                23.04
            ],
            "text": " if a is zero if a becomes zero and the wild loop is false can I say the GCD will be b I will"
        },
        {
            "timestamp": [
                23.68,
                29.36
            ],
            "text": " or else can I say the GCD will be print of a simple simple as simple"
        },
        {
            "timestamp": [
                0.0,
                1.0
            ],
            "text": " Yes."
        },
        {
            "timestamp": [
                1.0,
                7.32
            ],
            "text": " You can just take this example 52.10 and you can do a dry run on this."
        },
        {
            "timestamp": [
                7.32,
                13.4
            ],
            "text": " And you will see that eventually one of them will become zero and that is when the looping ends."
        },
        {
            "timestamp": [
                13.4,
                21.6
            ],
            "text": " And the time complexity of this equilardine algorithm is we go of log of phi, minimum of"
        },
        {
            "timestamp": [
                21.6,
                23.2
            ],
            "text": " A comma B."
        },
        {
            "timestamp": [
                23.2,
                26.2
            ],
            "text": " Why log?"
        },
        {
            "timestamp": [
                26.2,
                29.98
            ],
            "text": " If you remember, I clearly stated during the digit extract."
        },
        {
            "timestamp": [
                0.0,
                6.6
            ],
            "text": " or in the pattern videos or the time complexity videos that whenever there is division happening"
        },
        {
            "timestamp": [
                6.6,
                12.4
            ],
            "text": " whenever there is division happening the number of iterations will be in terms of logarithm"
        },
        {
            "timestamp": [
                12.4,
                19.52
            ],
            "text": " over here there is modulo you are reducing the number by division the modulation operations are"
        },
        {
            "timestamp": [
                19.52,
                26.08
            ],
            "text": " happening thereby the time complexity will be in terms of logarithm now why if i why not something"
        },
        {
            "timestamp": [
                26.08,
                29.92
            ],
            "text": " like log based in the digit extraction it is always"
        },
        {
            "timestamp": [
                0.0,
                8.16
            ],
            "text": " is n by 10 over here this a and v it's always changing fluctuated you're not sure what will be"
        },
        {
            "timestamp": [
                8.16,
                14.16
            ],
            "text": " a and v depending on different examples it will fluctuate that is why they're given them given it a"
        },
        {
            "timestamp": [
                14.16,
                20.4
            ],
            "text": " term phi if you want to know what is phi in depth there's a huge mathematical proof to it not required"
        },
        {
            "timestamp": [
                20.4,
                26.24
            ],
            "text": " you can read it but it's not required and minimum of a comma b because that is the initial"
        },
        {
            "timestamp": [
                26.24,
                29.98
            ],
            "text": " number where you start from as the initial number we start to do it"
        },
        {
            "timestamp": [
                0.0,
                2.7
            ],
            "text": " So that's why the time complexity is this."
        },
        {
            "timestamp": [
                3.5,
                6.1
            ],
            "text": " No one is going to ask you how and everything."
        },
        {
            "timestamp": [
                6.1,
                11.2
            ],
            "text": " Just keep it in mind that the time complexity is log 5 minimum of A comma B."
        },
        {
            "timestamp": [
                11.2,
                12.4
            ],
            "text": " This is the equality now."
        },
        {
            "timestamp": [
                14.1,
                19.8
            ],
            "text": " So written the same code after if I've not given else because if this line doesn't,"
        },
        {
            "timestamp": [
                19.8,
                24.2
            ],
            "text": " if this line executes the function would have end and this line will not execute."
        },
        {
            "timestamp": [
                24.2,
                24.8
            ],
            "text": " That's why."
        },
        {
            "timestamp": [
                24.8,
                29.1
            ],
            "text": " So now I'll go ahead and run this code and it is running absolutely fine."
        },
        {
            "timestamp": [
                0.0,
                2.56
            ],
            "text": " and if I'll submit this, we get the correct answer."
        },
        {
            "timestamp": [
                3.16,
                5.38
            ],
            "text": " So with this, we'll be wrapping up the basic maths."
        },
        {
            "timestamp": [
                5.82,
                7.16
            ],
            "text": " Next is basic recursion."
        },
        {
            "timestamp": [
                7.22,
                8.58
            ],
            "text": " I've already made videos on it."
        },
        {
            "timestamp": [
                8.66,
                9.98
            ],
            "text": " I'll be attaching them to the playlist."
        },
        {
            "timestamp": [
                10.56,
                12.48
            ],
            "text": " So watch this match video."
        },
        {
            "timestamp": [
                12.96,
                15.08
            ],
            "text": " Post that go and watch the basic recursion video."
        },
        {
            "timestamp": [
                15.64,
                20.38
            ],
            "text": " Once you have done this, then we will be going across to the next topic."
        },
        {
            "timestamp": [
                20.46,
                24.5
            ],
            "text": " That is basic hashing and I'll be explaining hashing in depth."
        },
        {
            "timestamp": [
                24.76,
                29.98
            ],
            "text": " But I hope for this video, you've understood basic maths completely just in case you"
        },
        {
            "timestamp": [
                0.0,
                5.66
            ],
            "text": " have please hit that like button and to follow a ritual do comment understood so that i get an idea"
        },
        {
            "timestamp": [
                5.66,
                10.16
            ],
            "text": " that you guys are understanding and you watch the video till here if you're new to our channel"
        },
        {
            "timestamp": [
                10.16,
                15.44
            ],
            "text": " what are you please please do consider subscribing to us because that is the only thing that keeps me"
        },
        {
            "timestamp": [
                15.44,
                19.88
            ],
            "text": " motivated to make these kind of content and here with this i'll be wrapping up this video let's be in some"
        },
        {
            "timestamp": [
                19.88,
                27.4
            ],
            "text": " of the video till then goodbye to you know whenever your heart is broken don't ever forget your"
        },
        {
            "timestamp": [
                0.0,
                0.64
            ],
            "text": " I didn't."
        }
    ]
}